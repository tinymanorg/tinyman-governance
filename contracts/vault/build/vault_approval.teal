#pragma version 9
//tealish version git+https://github.com/Hipo/tealish.git@c4f8c12b36dbcc8b63844df5f818164925735087

// Name: <address>
// Size: 32 bytes

// Name: <address><box_index><array_index>
// Size: 48 bytes (8+8+16+16). 1 Box(1008) = 21 AccountPower

// Name: tp<box_index><array_index>
// Size: 48 bytes (8+8+16+16). 1 Box(1008) = 21 TotalPower

// sc<timestamp>
// 16 bytes

// 7 * DAY
#define WEEK 604800
// 4 * 52 * WEEK
#define MAX_LOCK_TIME 125798400
#define MIN_LOCK_AMOUNT 10000000
#define MIN_LOCK_AMOUNT_INCREMENT 10000000
#define TWO_TO_THE_64 "\x01\x00\x00\x00\x00\x00\x00\x00\x00"

// Boxes
#define TOTAL_POWER_BOX_PREFIX "tp"
#define TOTAL_POWER_SIZE 48
#define TOTAL_POWER_BOX_SIZE 1008
#define TOTAL_POWER_BOX_ARRAY_LEN 21

#define ACCOUNT_STATE_SIZE 32

#define ACCOUNT_POWER_SIZE 48
#define ACCOUNT_POWER_BOX_SIZE 1008
#define ACCOUNT_POWER_BOX_ARRAY_LEN 21

#define SLOPE_CHANGE_BOX_PREFIX "sc"
#define SLOPE_CHANGE_SIZE 16

// Keys
#define TINY_ASSET_ID_KEY "tiny_asset_id"
#define TOTAL_LOCKED_AMOUNT_KEY "total_locked_amount"
#define TOTAL_POWER_COUNT_KEY "total_power_count"
#define LAST_TOTAL_POWER_TIMESTAMP "last_total_power_timestamp"


// tl:67: router:
pushbytes "create_application"
pushbytes "increase_budget"
pushbytes "create_lock"
pushbytes "increase_lock_amount"
pushbytes "extend_lock_end_time"
pushbytes "create_checkpoints"
pushbytes "get_tiny_power_of"
pushbytes "get_tiny_power_of_at"
pushbytes "get_total_tiny_power"
pushbytes "get_total_tiny_power_at"
pushbytes "get_cumulative_power_of_at"
pushbytes "get_total_cumulative_power_at"
pushbytes "get_account_cumulative_power_delta"
pushbytes "get_total_cumulative_power_delta"
pushbytes "withdraw"
pushbytes "get_box"
pushbytes "delete_account_power_boxes"
pushbytes "delete_account_state"
pushbytes "init"
txna ApplicationArgs 0
match route_create_application route_increase_budget route_create_lock route_increase_lock_amount route_extend_lock_end_time route_create_checkpoints route_get_tiny_power_of route_get_tiny_power_of_at route_get_total_tiny_power route_get_total_tiny_power_at route_get_cumulative_power_of_at route_get_total_cumulative_power_at route_get_account_cumulative_power_delta route_get_total_cumulative_power_delta route_withdraw route_get_box route_delete_account_power_boxes route_delete_account_state route_init
err                                                         // unexpected value
route_create_application:
    txn ApplicationID; pushint 0; ==; assert                // ApplicationID == 0
    txna ApplicationArgs 1; btoi 
    callsub __func__create_application
    pushint 1; return
route_increase_budget:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    callsub __func__increase_budget
    pushint 1; return
route_create_lock:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    txna ApplicationArgs 1; btoi 
    callsub __func__create_lock
    pushint 1; return
route_increase_lock_amount:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    callsub __func__increase_lock_amount
    pushint 1; return
route_extend_lock_end_time:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    txna ApplicationArgs 1; btoi 
    callsub __func__extend_lock_end_time
    pushint 1; return
route_create_checkpoints:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    callsub __func__create_checkpoints
    pushint 1; return
route_get_tiny_power_of:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    txna ApplicationArgs 1; dup; len; pushint 32; ==; assert// Bytes Size Assertion: 32 bytes
    callsub __func__get_tiny_power_of
    // return int
    // uncover 0 int
    itob
    pushbytes 0x151f7c75; swap; concat; log                 // arc4 return log
    pushint 1; return
route_get_tiny_power_of_at:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    txna ApplicationArgs 1; dup; len; pushint 32; ==; assert// Bytes Size Assertion: 32 bytes
    txna ApplicationArgs 2; btoi 
    txna ApplicationArgs 3; btoi 
    callsub __func__get_tiny_power_of_at
    // return int
    // uncover 0 int
    itob
    pushbytes 0x151f7c75; swap; concat; log                 // arc4 return log
    pushint 1; return
route_get_total_tiny_power:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    callsub __func__get_total_tiny_power
    // return int
    // uncover 0 int
    itob
    pushbytes 0x151f7c75; swap; concat; log                 // arc4 return log
    pushint 1; return
route_get_total_tiny_power_at:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    txna ApplicationArgs 1; btoi 
    txna ApplicationArgs 2; btoi 
    callsub __func__get_total_tiny_power_at
    // return int
    // uncover 0 int
    itob
    pushbytes 0x151f7c75; swap; concat; log                 // arc4 return log
    pushint 1; return
route_get_cumulative_power_of_at:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    txna ApplicationArgs 1; dup; len; pushint 32; ==; assert// Bytes Size Assertion: 32 bytes
    txna ApplicationArgs 2; btoi 
    txna ApplicationArgs 3; btoi 
    callsub __func__get_cumulative_power_of_at
    // return bytes
    // uncover 0 bytes
    pushbytes 0x151f7c75; swap; concat; log                 // arc4 return log
    pushint 1; return
route_get_total_cumulative_power_at:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    txna ApplicationArgs 1; btoi 
    txna ApplicationArgs 2; btoi 
    callsub __func__get_total_cumulative_power_at
    // return bytes
    // uncover 0 bytes
    pushbytes 0x151f7c75; swap; concat; log                 // arc4 return log
    pushint 1; return
route_get_account_cumulative_power_delta:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    txna ApplicationArgs 1; dup; len; pushint 32; ==; assert// Bytes Size Assertion: 32 bytes
    txna ApplicationArgs 2; btoi 
    txna ApplicationArgs 3; btoi 
    txna ApplicationArgs 4; btoi 
    txna ApplicationArgs 5; btoi 
    callsub __func__get_account_cumulative_power_delta
    // return bytes
    // uncover 0 bytes
    pushbytes 0x151f7c75; swap; concat; log                 // arc4 return log
    pushint 1; return
route_get_total_cumulative_power_delta:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    txna ApplicationArgs 1; btoi 
    txna ApplicationArgs 2; btoi 
    txna ApplicationArgs 3; btoi 
    txna ApplicationArgs 4; btoi 
    callsub __func__get_total_cumulative_power_delta
    // return bytes
    // uncover 0 bytes
    pushbytes 0x151f7c75; swap; concat; log                 // arc4 return log
    pushint 1; return
route_withdraw:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    callsub __func__withdraw
    pushint 1; return
route_get_box:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    txna ApplicationArgs 1
    callsub __func__get_box
    // return bytes, bytes
    // uncover 0 bytes
    uncover 1                                               // bytes
    concat
    pushbytes 0x151f7c75; swap; concat; log                 // arc4 return log
    pushint 1; return
route_delete_account_power_boxes:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    txna ApplicationArgs 1; btoi 
    callsub __func__delete_account_power_boxes
    pushint 1; return
route_delete_account_state:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    callsub __func__delete_account_state
    pushint 1; return
route_init:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    callsub __func__init
    pushint 1; return


// tl:91: func create_application(tiny_asset_id: int):
__func__create_application:
    store 1                                                 // tiny_asset_id [int]
    // tl:92: app_global_put(TINY_ASSET_ID_KEY, tiny_asset_id)
    pushbytes TINY_ASSET_ID_KEY                             // "tiny_asset_id"
    load 1                                                  // tiny_asset_id
    app_global_put
    // tl:93: app_global_put(TOTAL_LOCKED_AMOUNT_KEY, 0)
    pushbytes TOTAL_LOCKED_AMOUNT_KEY                       // "total_locked_amount"
    pushint 0
    app_global_put
    // tl:94: app_global_put(TOTAL_POWER_COUNT_KEY, 0)
    pushbytes TOTAL_POWER_COUNT_KEY                         // "total_power_count"
    pushint 0
    app_global_put
    // tl:95: app_global_put(LAST_TOTAL_POWER_TIMESTAMP, 0)
    pushbytes LAST_TOTAL_POWER_TIMESTAMP                    // "last_total_power_timestamp"
    pushint 0
    app_global_put
    // tl:96: return
    retsub

// tl:100: func increase_budget():
__func__increase_budget:
    // Box read budget and opcode budget will be incread using this method.
    // tl:102: return
    retsub

// tl:106: func init():
__func__init:
    // create the first total power
    // tl:108: assert(!app_global_get(TOTAL_POWER_COUNT_KEY))
    pushbytes TOTAL_POWER_COUNT_KEY                         // "total_power_count"
    app_global_get
    !
    assert
    // tl:109: TotalPower total_power = construct_total_power(0, Global.LatestTimestamp, bzero(16), bzero(16)) [slot 2]
    pushint 0
    global LatestTimestamp
    pushint 16
    bzero
    pushint 16
    bzero
    callsub __func__construct_total_power
    store 2                                                 // total_power
    // tl:110: save_total_power(total_power)
    load 2                                                  // total_power
    callsub __func__save_total_power
    
    // opt-in to TINY
    // tl:113: tiny_transfer(0, Global.CurrentApplicationAddress, Global.CurrentApplicationAddress)
    pushint 0
    global CurrentApplicationAddress
    global CurrentApplicationAddress
    callsub __func__tiny_transfer
    // tl:114: log(method("init()"))
    method "init()"
    log
    // tl:115: return
    retsub

// tl:119: func create_checkpoints():
__func__create_checkpoints:
    // tl:120: create_checkpoints_internal(0, bzero(16), 0)
    pushint 0
    pushint 16
    bzero
    pushint 0
    callsub __func__create_checkpoints_internal
    // tl:121: log(method("create_checkpoints()"))
    method "create_checkpoints()"
    log
    // tl:122: return
    retsub

// tl:126: func create_lock(lock_end_time: int):
__func__create_lock:
    store 3                                                 // lock_end_time [int]
    // This method is responsible for initiating a new lock for two categories of accounts:
    // 1) Accounts which have never had a token lock before.
    // 2) Accounts that have previously withdrawn their locked token amount.
    
    // tl:131: bytes[32] user_address = Txn.Sender [slot 4]
    txn Sender
    store 4                                                 // user_address
    // tl:132: int amount = get_received_tiny_amount() [slot 5]
    callsub __func__get_received_tiny_amount
    store 5                                                 // amount
    
    // amount must be at least the minimum
    // tl:135: assert(amount >= MIN_LOCK_AMOUNT)
    load 5                                                  // amount
    pushint MIN_LOCK_AMOUNT                                 // 10000000
    >=
    assert
    // lock end time must be a the start of a week
    // tl:137: assert(!(lock_end_time % WEEK))
    load 3                                                  // lock_end_time
    pushint WEEK                                            // 604800
    %
    !
    assert
    // lock duration must be at least 4 weeks
    // tl:139: assert(lock_end_time >= (Global.LatestTimestamp + (4 * WEEK)))
    load 3                                                  // lock_end_time
    global LatestTimestamp
    pushint 4
    pushint WEEK                                            // 604800
    *
    +
    >=
    assert
    // lock duration must be no more than the max lock time
    // tl:141: assert(lock_end_time <= (Global.LatestTimestamp + MAX_LOCK_TIME))
    load 3                                                  // lock_end_time
    global LatestTimestamp
    pushint MAX_LOCK_TIME                                   // 125798400
    +
    <=
    assert
    
    // Get or create the account state box
    // An account may have state box if it is not locking first time.
    // tl:145: _ = box_create(user_address, ACCOUNT_STATE_SIZE)
    load 4                                                  // user_address
    pushint ACCOUNT_STATE_SIZE                              // 32
    box_create
    pop                                                     // discarding value for _
    // tl:146: box<AccountState> account_state = Box(user_address) [slot 6]
    load 4                                                  // user_address
    store 6                                                 // box:account_state
    
    // Ensure that the account either has no previous lock or any existing locks have been fully withdrawn
    // tl:149: assert(!account_state.locked_amount)
    load 6; pushint 0; pushint 8; box_extract; btoi// account_state.locked_amount
    !
    assert
    
    // Update the account state
    // tl:152: account_state.locked_amount = amount
    load 5                                                  // amount
    itob; load 6; pushint 0; uncover 2; box_replace// boxset account_state.locked_amount
    // tl:153: account_state.lock_end_time = lock_end_time
    load 3                                                  // lock_end_time
    itob; load 6; pushint 8; uncover 2; box_replace// boxset account_state.lock_end_time
    
    // Increase the power count by one
    // tl:156: int account_power_index = account_state.power_count [slot 7]
    load 6; pushint 16; pushint 8; box_extract; btoi// account_state.power_count
    store 7                                                 // account_power_index
    // tl:157: account_state.power_count = account_power_index + 1
    load 7                                                  // account_power_index
    pushint 1
    +
    itob; load 6; pushint 16; uncover 2; box_replace// boxset account_state.power_count
    
    // Calculate the current slope and bias
    // tl:160: bytes slope = get_slope(amount) [slot 8]
    load 5                                                  // amount
    callsub __func__get_slope
    store 8                                                 // slope
    // tl:161: int bias = get_bias(slope, (lock_end_time - Global.LatestTimestamp)) [slot 9]
    load 8                                                  // slope
    load 3                                                  // lock_end_time
    global LatestTimestamp
    -
    callsub __func__get_bias
    store 9                                                 // bias
    
    // tl:163: bytes cumulative_power [slot 10]
    // tl:164: if account_power_index:
    load 7                                                  // account_power_index
    bz l0_else
    // then:
        // Account type 2
        // tl:166: AccountPower last_account_power = get_account_power(user_address, account_power_index - 1) [slot 11]
        load 4                                              // user_address
        load 7                                              // account_power_index
        pushint 1
        -
        callsub __func__get_account_power
        store 11                                            // last_account_power
        // tl:167: cumulative_power = last_account_power.cumulative_power
        load 11; extract 32 16// last_account_power.cumulative_power
        store 10                                            // cumulative_power
        b l0_end
    l0_else:
    // tl:168: else:
        // Account type 1
        // tl:170: cumulative_power = bzero(16)
        pushint 16
        bzero
        store 10                                            // cumulative_power
    l0_end:
    
    // Crate a new account power
    // tl:174: AccountPower account_power = construct_account_power(bias, Global.LatestTimestamp, slope, cumulative_power) [slot 12]
    load 9                                                  // bias
    global LatestTimestamp
    load 8                                                  // slope
    load 10                                                 // cumulative_power
    callsub __func__construct_account_power
    store 12                                                // account_power
    // tl:175: save_account_power(user_address, account_power_index, account_power)
    load 4                                                  // user_address
    load 7                                                  // account_power_index
    load 12                                                 // account_power
    callsub __func__save_account_power
    
    // Create checkpoint for Total Power
    // tl:178: create_checkpoints_internal(bias, slope, 1)
    load 9                                                  // bias
    load 8                                                  // slope
    pushint 1
    callsub __func__create_checkpoints_internal
    // Schedule a future slope change for when the lock expires
    // tl:180: update_or_create_slope_change(lock_end_time, slope)
    load 3                                                  // lock_end_time
    load 8                                                  // slope
    callsub __func__update_or_create_slope_change
    // tl:181: increase_total_locked_amount(amount)
    load 5                                                  // amount
    callsub __func__increase_total_locked_amount
    
    // create_lock(address, locked_amount, lock_end_time)
    // tl:184: log(Concat(method("create_lock(address,uint64,uint64)"), user_address, box_extract(user_address, 0, 16)))
    method "create_lock(address,uint64,uint64)"
    load 4                                                  // user_address
    load 4                                                  // user_address
    pushint 0
    pushint 16
    box_extract
    concat
    concat
    log
    // tl:185: return
    retsub

// tl:189: func increase_lock_amount():
__func__increase_lock_amount:
    // This method enables users to increase their currently locked token amount before the lock expiration time.
    
    // tl:192: bytes[32] user_address = Txn.Sender [slot 13]
    txn Sender
    store 13                                                // user_address
    // tl:193: int amount = get_received_tiny_amount() [slot 14]
    callsub __func__get_received_tiny_amount
    store 14                                                // amount
    
    // Amount must be at least the minimum increment
    // tl:196: assert(amount >= MIN_LOCK_AMOUNT_INCREMENT)
    load 14                                                 // amount
    pushint MIN_LOCK_AMOUNT_INCREMENT                       // 10000000
    >=
    assert
    
    // Get the current AccountState box (must already exist)
    // tl:199: box<AccountState> account_state = OpenBox(user_address) [slot 15]
    load 13                                                 // user_address
    dup; box_len; assert; pushint 32; ==; assert            // len(box) == AccountState.size
    store 15                                                // box:account_state
    
    // Ensure that current lock is not expired.
    // tl:202: int lock_end_time = account_state.lock_end_time [slot 16]
    load 15; pushint 8; pushint 8; box_extract; btoi// account_state.lock_end_time
    store 16                                                // lock_end_time
    // tl:203: assert(lock_end_time > Global.LatestTimestamp)
    load 16                                                 // lock_end_time
    global LatestTimestamp
    >
    assert
    
    // Update locked_amount, power_count
    // tl:206: int old_locked_amount = account_state.locked_amount [slot 17]
    load 15; pushint 0; pushint 8; box_extract; btoi// account_state.locked_amount
    store 17                                                // old_locked_amount
    // tl:207: int new_locked_amount = old_locked_amount + amount [slot 18]
    load 17                                                 // old_locked_amount
    load 14                                                 // amount
    +
    store 18                                                // new_locked_amount
    // tl:208: account_state.locked_amount = new_locked_amount
    load 18                                                 // new_locked_amount
    itob; load 15; pushint 0; uncover 2; box_replace// boxset account_state.locked_amount
    
    // Increase the power count by one.
    // tl:211: int account_power_index = account_state.power_count [slot 19]
    load 15; pushint 16; pushint 8; box_extract; btoi// account_state.power_count
    store 19                                                // account_power_index
    // tl:212: account_state.power_count = account_power_index + 1
    load 19                                                 // account_power_index
    pushint 1
    +
    itob; load 15; pushint 16; uncover 2; box_replace// boxset account_state.power_count
    
    // Calculate the new slope & bias and the slope_delta & bias_delta
    // tl:215: bytes old_locked_amount_slope = get_slope(old_locked_amount) [slot 20]
    load 17                                                 // old_locked_amount
    callsub __func__get_slope
    store 20                                                // old_locked_amount_slope
    // tl:216: bytes new_locked_amount_slope = get_slope(new_locked_amount) [slot 21]
    load 18                                                 // new_locked_amount
    callsub __func__get_slope
    store 21                                                // new_locked_amount_slope
    // tl:217: bytes slope_delta = new_locked_amount_slope b- old_locked_amount_slope [slot 22]
    load 21                                                 // new_locked_amount_slope
    load 20                                                 // old_locked_amount_slope
    b-
    store 22                                                // slope_delta
    
    // tl:219: int current_bias = get_bias(old_locked_amount_slope, (lock_end_time - Global.LatestTimestamp)) [slot 23]
    load 20                                                 // old_locked_amount_slope
    load 16                                                 // lock_end_time
    global LatestTimestamp
    -
    callsub __func__get_bias
    store 23                                                // current_bias
    // tl:220: int new_bias = get_bias(new_locked_amount_slope, (lock_end_time - Global.LatestTimestamp)) [slot 24]
    load 21                                                 // new_locked_amount_slope
    load 16                                                 // lock_end_time
    global LatestTimestamp
    -
    callsub __func__get_bias
    store 24                                                // new_bias
    // tl:221: int bias_delta = new_bias - current_bias [slot 25]
    load 24                                                 // new_bias
    load 23                                                 // current_bias
    -
    store 25                                                // bias_delta
    
    // Create a new AccountPower based on the previous AccountPower
    // tl:224: AccountPower last_account_power = get_account_power(user_address, account_power_index - 1) [slot 26]
    load 13                                                 // user_address
    load 19                                                 // account_power_index
    pushint 1
    -
    callsub __func__get_account_power
    store 26                                                // last_account_power
    // tl:225: int time_delta = Global.LatestTimestamp - last_account_power.timestamp [slot 27]
    global LatestTimestamp
    load 26; extract 8 8; btoi// last_account_power.timestamp
    -
    store 27                                                // time_delta
    
    // Using get_cumulative_power_1 is safe because the lock is not expired.
    // tl:228: bytes cumulative_power = last_account_power.cumulative_power b+ get_cumulative_power_1(last_account_power.bias, current_bias, time_delta) [slot 28]
    load 26; extract 32 16// last_account_power.cumulative_power
    load 26; extract 0 8; btoi// last_account_power.bias
    load 23                                                 // current_bias
    load 27                                                 // time_delta
    callsub __func__get_cumulative_power_1
    b+
    store 28                                                // cumulative_power
    
    // Crate a new account power
    // tl:231: AccountPower account_power = construct_account_power(new_bias, Global.LatestTimestamp, new_locked_amount_slope, cumulative_power) [slot 29]
    load 24                                                 // new_bias
    global LatestTimestamp
    load 21                                                 // new_locked_amount_slope
    load 28                                                 // cumulative_power
    callsub __func__construct_account_power
    store 29                                                // account_power
    // tl:232: save_account_power(user_address, account_power_index, account_power)
    load 13                                                 // user_address
    load 19                                                 // account_power_index
    load 29                                                 // account_power
    callsub __func__save_account_power
    
    // Create checkpoint for Total Power
    // tl:235: create_checkpoints_internal(bias_delta, slope_delta, 1)
    load 25                                                 // bias_delta
    load 22                                                 // slope_delta
    pushint 1
    callsub __func__create_checkpoints_internal
    
    // Modify the future scheduled slope change
    // tl:238: update_or_create_slope_change(lock_end_time, slope_delta)
    load 16                                                 // lock_end_time
    load 22                                                 // slope_delta
    callsub __func__update_or_create_slope_change
    // tl:239: increase_total_locked_amount(amount)
    load 14                                                 // amount
    callsub __func__increase_total_locked_amount
    
    // increase_lock_amount(address, locked_amount, lock_end_time, amount_delta)
    // tl:242: log(Concat(method("increase_lock_amount(address,uint64,uint64,uint64)"), user_address, box_extract(user_address, 0, 16), itob(amount)))
    method "increase_lock_amount(address,uint64,uint64,uint64)"
    load 13                                                 // user_address
    load 13                                                 // user_address
    pushint 0
    pushint 16
    box_extract
    load 14                                                 // amount
    itob
    concat
    concat
    concat
    log
    // tl:243: return
    retsub

// tl:247: func extend_lock_end_time(new_lock_end_time: int):
__func__extend_lock_end_time:
    store 30                                                // new_lock_end_time [int]
    // This method enables users to extend remaining lock duration.
    
    // tl:250: bytes[32] user_address = Txn.Sender [slot 31]
    txn Sender
    store 31                                                // user_address
    
    // Get the current AccountState
    // tl:253: box<AccountState> account_state = OpenBox(user_address) [slot 32]
    load 31                                                 // user_address
    dup; box_len; assert; pushint 32; ==; assert            // len(box) == AccountState.size
    store 32                                                // box:account_state
    // tl:254: int current_lock_end_time = account_state.lock_end_time [slot 33]
    load 32; pushint 8; pushint 8; box_extract; btoi// account_state.lock_end_time
    store 33                                                // current_lock_end_time
    // The lock must still be active
    // tl:256: assert(current_lock_end_time > Global.LatestTimestamp)
    load 33                                                 // current_lock_end_time
    global LatestTimestamp
    >
    assert
    
    // The new lock end time must be the start of a week
    // tl:259: assert(!(new_lock_end_time % WEEK))
    load 30                                                 // new_lock_end_time
    pushint WEEK                                            // 604800
    %
    !
    assert
    // The new duration must be no more than the max lock time
    // tl:261: assert(new_lock_end_time <= (Global.LatestTimestamp + MAX_LOCK_TIME))
    load 30                                                 // new_lock_end_time
    global LatestTimestamp
    pushint MAX_LOCK_TIME                                   // 125798400
    +
    <=
    assert
    // The new duration must be at least the minimum
    // tl:263: assert(new_lock_end_time >= (current_lock_end_time + (4 * WEEK)))
    load 30                                                 // new_lock_end_time
    load 33                                                 // current_lock_end_time
    pushint 4
    pushint WEEK                                            // 604800
    *
    +
    >=
    assert
    // ensured indirectly
    // assert(new_lock_end_time > Global.LatestTimestamp)
    
    // Increase the power count by one.
    // tl:268: int account_power_index = account_state.power_count [slot 34]
    load 32; pushint 16; pushint 8; box_extract; btoi// account_state.power_count
    store 34                                                // account_power_index
    // tl:269: account_state.power_count = account_power_index + 1
    load 34                                                 // account_power_index
    pushint 1
    +
    itob; load 32; pushint 16; uncover 2; box_replace// boxset account_state.power_count
    // tl:270: account_state.lock_end_time = new_lock_end_time
    load 30                                                 // new_lock_end_time
    itob; load 32; pushint 8; uncover 2; box_replace// boxset account_state.lock_end_time
    
    // Calculate the slope, new bias and bias_delta
    // tl:273: bytes slope = get_slope(account_state.locked_amount) [slot 35]
    load 32; pushint 0; pushint 8; box_extract; btoi// account_state.locked_amount
    callsub __func__get_slope
    store 35                                                // slope
    // tl:274: int current_bias = get_bias(slope, (current_lock_end_time - Global.LatestTimestamp)) [slot 36]
    load 35                                                 // slope
    load 33                                                 // current_lock_end_time
    global LatestTimestamp
    -
    callsub __func__get_bias
    store 36                                                // current_bias
    // tl:275: int new_bias = get_bias(slope, (new_lock_end_time - Global.LatestTimestamp)) [slot 37]
    load 35                                                 // slope
    load 30                                                 // new_lock_end_time
    global LatestTimestamp
    -
    callsub __func__get_bias
    store 37                                                // new_bias
    // tl:276: int bias_delta = new_bias - current_bias [slot 38]
    load 37                                                 // new_bias
    load 36                                                 // current_bias
    -
    store 38                                                // bias_delta
    
    // Create a new AccountPower based on the previous AccountPower
    // tl:279: AccountPower last_account_power = get_account_power(user_address, account_power_index - 1) [slot 39]
    load 31                                                 // user_address
    load 34                                                 // account_power_index
    pushint 1
    -
    callsub __func__get_account_power
    store 39                                                // last_account_power
    // tl:280: int time_delta = Global.LatestTimestamp - last_account_power.timestamp [slot 40]
    global LatestTimestamp
    load 39; extract 8 8; btoi// last_account_power.timestamp
    -
    store 40                                                // time_delta
    // tl:281: bytes cumulative_power = last_account_power.cumulative_power b+ get_cumulative_power_1(last_account_power.bias, current_bias, time_delta) [slot 41]
    load 39; extract 32 16// last_account_power.cumulative_power
    load 39; extract 0 8; btoi// last_account_power.bias
    load 36                                                 // current_bias
    load 40                                                 // time_delta
    callsub __func__get_cumulative_power_1
    b+
    store 41                                                // cumulative_power
    
    // Create AccountPower
    // tl:284: AccountPower account_power = construct_account_power(new_bias, Global.LatestTimestamp, slope, cumulative_power) [slot 42]
    load 37                                                 // new_bias
    global LatestTimestamp
    load 35                                                 // slope
    load 41                                                 // cumulative_power
    callsub __func__construct_account_power
    store 42                                                // account_power
    // tl:285: save_account_power(user_address, account_power_index, account_power)
    load 31                                                 // user_address
    load 34                                                 // account_power_index
    load 42                                                 // account_power
    callsub __func__save_account_power
    
    // Create checkpoint for Total Power
    // tl:288: create_checkpoints_internal(bias_delta, bzero(16), 1)
    load 38                                                 // bias_delta
    pushint 16
    bzero
    pushint 1
    callsub __func__create_checkpoints_internal
    // Revert the future scheduled slope change for the current lock end time
    // tl:290: revert_slope_change(current_lock_end_time, slope)
    load 33                                                 // current_lock_end_time
    load 35                                                 // slope
    callsub __func__revert_slope_change
    // Schedule a new slope change for the new lock end time
    // tl:292: update_or_create_slope_change(new_lock_end_time, slope)
    load 30                                                 // new_lock_end_time
    load 35                                                 // slope
    callsub __func__update_or_create_slope_change
    
    // extend_lock_end_time(address, locked_amount, lock_end_time, lock_end_time_delta)
    // tl:295: log(Concat(method("extend_lock_end_time(address,uint64,uint64,uint64)"), user_address, box_extract(user_address, 0, 16), itob(new_lock_end_time - current_lock_end_time)))
    method "extend_lock_end_time(address,uint64,uint64,uint64)"
    load 31                                                 // user_address
    load 31                                                 // user_address
    pushint 0
    pushint 16
    box_extract
    load 30                                                 // new_lock_end_time
    load 33                                                 // current_lock_end_time
    -
    itob
    concat
    concat
    concat
    log
    // tl:296: return
    retsub

// tl:300: func withdraw():
__func__withdraw:
    // tl:301: bytes[32] user_address = Txn.Sender [slot 43]
    txn Sender
    store 43                                                // user_address
    
    // tl:303: box<AccountState> account_state = OpenBox(user_address) [slot 44]
    load 43                                                 // user_address
    dup; box_len; assert; pushint 32; ==; assert            // len(box) == AccountState.size
    store 44                                                // box:account_state
    // tl:304: int locked_amount = account_state.locked_amount [slot 45]
    load 44; pushint 0; pushint 8; box_extract; btoi// account_state.locked_amount
    store 45                                                // locked_amount
    
    // tl:306: assert(locked_amount)
    load 45                                                 // locked_amount
    assert
    // The lock must have expired
    // tl:308: assert(account_state.lock_end_time < Global.LatestTimestamp)
    load 44; pushint 8; pushint 8; box_extract; btoi// account_state.lock_end_time
    global LatestTimestamp
    <
    assert
    
    // Create the final AccountPower recording the final state
    // tl:311: int account_power_index = account_state.power_count [slot 46]
    load 44; pushint 16; pushint 8; box_extract; btoi// account_state.power_count
    store 46                                                // account_power_index
    // tl:312: account_state.power_count = account_power_index + 1
    load 46                                                 // account_power_index
    pushint 1
    +
    itob; load 44; pushint 16; uncover 2; box_replace// boxset account_state.power_count
    
    // tl:314: AccountPower last_account_power = get_account_power(user_address, account_power_index - 1) [slot 47]
    load 43                                                 // user_address
    load 46                                                 // account_power_index
    pushint 1
    -
    callsub __func__get_account_power
    store 47                                                // last_account_power
    // tl:315: bytes cumulative_power = last_account_power.cumulative_power b+ get_cumulative_power_1(last_account_power.bias, 0, account_state.lock_end_time - last_account_power.timestamp) [slot 48]
    load 47; extract 32 16// last_account_power.cumulative_power
    load 47; extract 0 8; btoi// last_account_power.bias
    pushint 0
    load 44; pushint 8; pushint 8; box_extract; btoi// account_state.lock_end_time
    load 47; extract 8 8; btoi// last_account_power.timestamp
    -
    callsub __func__get_cumulative_power_1
    b+
    store 48                                                // cumulative_power
    
    // Create AccountPower
    // tl:318: AccountPower account_power = construct_account_power(0, account_state.lock_end_time, bzero(16), cumulative_power) [slot 49]
    pushint 0
    load 44; pushint 8; pushint 8; box_extract; btoi// account_state.lock_end_time
    pushint 16
    bzero
    load 48                                                 // cumulative_power
    callsub __func__construct_account_power
    store 49                                                // account_power
    // tl:319: save_account_power(user_address, account_power_index, account_power)
    load 43                                                 // user_address
    load 46                                                 // account_power_index
    load 49                                                 // account_power
    callsub __func__save_account_power
    
    // Transfer the locked amount back to the user
    // tl:322: tiny_transfer(locked_amount, Global.CurrentApplicationAddress, user_address)
    load 45                                                 // locked_amount
    global CurrentApplicationAddress
    load 43                                                 // user_address
    callsub __func__tiny_transfer
    // tl:323: decrease_total_locked_amount(locked_amount)
    load 45                                                 // locked_amount
    callsub __func__decrease_total_locked_amount
    
    // Reset the AccountState
    // tl:326: account_state.locked_amount = 0
    pushint 0
    itob; load 44; pushint 0; uncover 2; box_replace// boxset account_state.locked_amount
    // tl:327: account_state.lock_end_time = 0
    pushint 0
    itob; load 44; pushint 8; uncover 2; box_replace// boxset account_state.lock_end_time
    
    // withdraw(user_address, amount)
    // tl:330: log(Concat(method("withdraw(address,uint64)"), user_address, itob(locked_amount)))
    method "withdraw(address,uint64)"
    load 43                                                 // user_address
    load 45                                                 // locked_amount
    itob
    concat
    concat
    log
    // tl:331: return
    retsub

// tl:335: func get_tiny_power_of(user_address: bytes[32]) int:
__func__get_tiny_power_of:
    store 50                                                // user_address [bytes[32]]
    // Current power can be calculated by using account state and account power.
    // The calculation is made using the account state to reduce required box references.
    // tl:338: int timestamp = Global.LatestTimestamp [slot 51]
    global LatestTimestamp
    store 51                                                // timestamp
    // tl:339: int tiny_power = 0 [slot 52]
    pushint 0
    store 52                                                // tiny_power
    
    // tl:341: int exists [slot 53]
    // tl:342: exists, _ = box_len(user_address)
    load 50                                                 // user_address
    box_len
    store 53                                                // exists
    pop                                                     // discarding value for _
    // tl:343: if exists:
    load 53                                                 // exists
    bz l1_end
    // then:
        // tl:344: box<AccountState> account_state = Box(user_address) [slot 54]
        load 50                                             // user_address
        store 54                                            // box:account_state
        // There is only power if the lock has not expired
        // tl:346: if account_state.lock_end_time > timestamp:
        load 54; pushint 8; pushint 8; box_extract; btoi// account_state.lock_end_time
        load 51                                             // timestamp
        >
        bz l2_end
        // then:
            // tl:347: int remaining_time = account_state.lock_end_time - timestamp [slot 55]
            load 54; pushint 8; pushint 8; box_extract; btoi// account_state.lock_end_time
            load 51                                         // timestamp
            -
            store 55                                        // remaining_time
            // tl:348: bytes slope = get_slope(account_state.locked_amount) [slot 56]
            load 54; pushint 0; pushint 8; box_extract; btoi// account_state.locked_amount
            callsub __func__get_slope
            store 56                                        // slope
            // tl:349: tiny_power = get_bias(slope, remaining_time)
            load 56                                         // slope
            load 55                                         // remaining_time
            callsub __func__get_bias
            store 52                                        // tiny_power
        l2_end:
    l1_end:
    
    // tl:353: return tiny_power
    load 52                                                 // tiny_power
    retsub

// tl:357: func get_tiny_power_of_at(user_address: bytes[32], timestamp: int, index: int) int:
__func__get_tiny_power_of_at:
    store 57                                                // index [int]
    store 58                                                // timestamp [int]
    store 59                                                // user_address [bytes[32]]
    // tl:358: int tiny_power = 0 [slot 60]
    pushint 0
    store 60                                                // tiny_power
    // tl:359: assert(timestamp <= Global.LatestTimestamp)
    load 58                                                 // timestamp
    global LatestTimestamp
    <=
    assert
    
    // tl:361: int exists [slot 61]
    // tl:362: exists, _ = box_len(user_address)
    load 59                                                 // user_address
    box_len
    store 61                                                // exists
    pop                                                     // discarding value for _
    // tl:363: if exists:
    load 61                                                 // exists
    bz l3_end
    // then:
        // tl:364: box<AccountState> account_state = Box(user_address) [slot 62]
        load 59                                             // user_address
        store 62                                            // box:account_state
        // The index must be valid
        // tl:366: assert(index < account_state.power_count)
        load 57                                             // index
        load 62; pushint 16; pushint 8; box_extract; btoi// account_state.power_count
        <
        assert
        
        // account_power.timestamp <= timestamp < next_account_power.timestamp
        // tl:369: AccountPower account_power = get_account_power(user_address, index) [slot 63]
        load 59                                             // user_address
        load 57                                             // index
        callsub __func__get_account_power
        store 63                                            // account_power
        // Ensure that this AccountPower is before the timestamp
        // tl:371: assert(account_power.timestamp <= timestamp)
        load 63; extract 8 8; btoi// account_power.timestamp
        load 58                                             // timestamp
        <=
        assert
        // Ensure that this is the last AccountPower before the timestamp
        // tl:373: if (index + 1) < account_state.power_count:
        load 57                                             // index
        pushint 1
        +
        load 62; pushint 16; pushint 8; box_extract; btoi// account_state.power_count
        <
        bz l4_end
        // then:
            // tl:374: AccountPower next_account_power = get_account_power(user_address, index + 1) [slot 64]
            load 59                                         // user_address
            load 57                                         // index
            pushint 1
            +
            callsub __func__get_account_power
            store 64                                        // next_account_power
            // tl:375: assert(timestamp < next_account_power.timestamp)
            load 58                                         // timestamp
            load 64; extract 8 8; btoi// next_account_power.timestamp
            <
            assert
        l4_end:
        // Calculate the power using the AccountPower checkpoint and the calculated power between the checkpoint and the timestamp
        // tl:378: tiny_power = get_power(account_power.bias, account_power.slope, (timestamp - account_power.timestamp))
        load 63; extract 0 8; btoi// account_power.bias
        load 63; extract 16 16// account_power.slope
        load 58                                             // timestamp
        load 63; extract 8 8; btoi// account_power.timestamp
        -
        callsub __func__get_power
        store 60                                            // tiny_power
    l3_end:
    
    // tl:381: return tiny_power
    load 60                                                 // tiny_power
    retsub

// tl:385: func get_total_tiny_power() int:
__func__get_total_tiny_power:
    // tl:386: int timestamp = Global.LatestTimestamp [slot 65]
    global LatestTimestamp
    store 65                                                // timestamp
    // Get the latest TotalPower
    // tl:388: int index = app_global_get(TOTAL_POWER_COUNT_KEY) - 1 [slot 66]
    pushbytes TOTAL_POWER_COUNT_KEY                         // "total_power_count"
    app_global_get
    pushint 1
    -
    store 66                                                // index
    // tl:389: TotalPower total_power = get_total_power(index) [slot 67]
    load 66                                                 // index
    callsub __func__get_total_power
    store 67                                                // total_power
    // Ensure that the latest checkpoint belongs to the same week so the slope is not changed.
    // tl:391: assert((total_power.timestamp / WEEK) == (timestamp / WEEK))
    load 67; extract 8 8; btoi// total_power.timestamp
    pushint WEEK                                            // 604800
    /
    load 65                                                 // timestamp
    pushint WEEK                                            // 604800
    /
    ==
    assert
    
    // Calculate the power since the stored power
    // tl:394: int tiny_power = get_power(total_power.bias, total_power.slope, (timestamp - total_power.timestamp)) [slot 68]
    load 67; extract 0 8; btoi// total_power.bias
    load 67; extract 16 16// total_power.slope
    load 65                                                 // timestamp
    load 67; extract 8 8; btoi// total_power.timestamp
    -
    callsub __func__get_power
    store 68                                                // tiny_power
    // tl:395: return tiny_power
    load 68                                                 // tiny_power
    retsub

// tl:399: func get_total_tiny_power_at(timestamp: int, total_power_index: int) int:
__func__get_total_tiny_power_at:
    store 69                                                // total_power_index [int]
    store 70                                                // timestamp [int]
    // tl:400: int tiny_power = 0 [slot 71]
    pushint 0
    store 71                                                // tiny_power
    // index must be valid
    // tl:402: assert(total_power_index < app_global_get(TOTAL_POWER_COUNT_KEY))
    load 69                                                 // total_power_index
    pushbytes TOTAL_POWER_COUNT_KEY                         // "total_power_count"
    app_global_get
    <
    assert
    // tl:403: assert(timestamp <= Global.LatestTimestamp)
    load 70                                                 // timestamp
    global LatestTimestamp
    <=
    assert
    
    // tl:405: TotalPower total_power = get_total_power(total_power_index) [slot 72]
    load 69                                                 // total_power_index
    callsub __func__get_total_power
    store 72                                                // total_power
    // Ensure that the latest checkpoint belongs to the same week so the slope is not changed.
    // tl:407: assert((total_power.timestamp / WEEK) == (timestamp / WEEK))
    load 72; extract 8 8; btoi// total_power.timestamp
    pushint WEEK                                            // 604800
    /
    load 70                                                 // timestamp
    pushint WEEK                                            // 604800
    /
    ==
    assert
    
    // Ensure that the TotalPower is before the timestamp
    // tl:410: if total_power.timestamp <= timestamp:
    load 72; extract 8 8; btoi// total_power.timestamp
    load 70                                                 // timestamp
    <=
    bz l5_else
    // then:
        // Ensure that the TotalPower is the last one before the timestamp
        // tl:412: if (total_power_index + 1) < app_global_get(TOTAL_POWER_COUNT_KEY):
        load 69                                             // total_power_index
        pushint 1
        +
        pushbytes TOTAL_POWER_COUNT_KEY                     // "total_power_count"
        app_global_get
        <
        bz l6_end
        // then:
            // tl:413: TotalPower next_total_power = get_total_power(total_power_index + 1) [slot 73]
            load 69                                         // total_power_index
            pushint 1
            +
            callsub __func__get_total_power
            store 73                                        // next_total_power
            // tl:414: assert(timestamp < next_total_power.timestamp)
            load 70                                         // timestamp
            load 73; extract 8 8; btoi// next_total_power.timestamp
            <
            assert
        l6_end:
        // Calculate the power since the stored power
        // tl:417: tiny_power = get_power(total_power.bias, total_power.slope, (timestamp - total_power.timestamp))
        load 72; extract 0 8; btoi// total_power.bias
        load 72; extract 16 16// total_power.slope
        load 70                                             // timestamp
        load 72; extract 8 8; btoi// total_power.timestamp
        -
        callsub __func__get_power
        store 71                                            // tiny_power
        b l5_end
    l5_else:
    // tl:418: else:
        // Index must be 0, it indicates that the given timestamp predates the first checkpoint.
        // tl:420: assert(!total_power_index)
        load 69                                             // total_power_index
        !
        assert
    l5_end:
    
    // tl:423: return tiny_power
    load 71                                                 // tiny_power
    retsub

// tl:427: func get_account_cumulative_power_delta(user_address: bytes[32], timestamp_1: int, timestamp_2: int, account_power_index_1: int, account_power_index_2: int) bytes:
__func__get_account_cumulative_power_delta:
    store 74                                                // account_power_index_2 [int]
    store 75                                                // account_power_index_1 [int]
    store 76                                                // timestamp_2 [int]
    store 77                                                // timestamp_1 [int]
    store 78                                                // user_address [bytes[32]]
    // tl:428: bytes account_cumulative_power_1 = get_cumulative_power_of_at(user_address, timestamp_1, account_power_index_1) [slot 79]
    load 78                                                 // user_address
    load 77                                                 // timestamp_1
    load 75                                                 // account_power_index_1
    callsub __func__get_cumulative_power_of_at
    store 79                                                // account_cumulative_power_1
    // tl:429: bytes account_cumulative_power_2 = get_cumulative_power_of_at(user_address, timestamp_2, account_power_index_2) [slot 80]
    load 78                                                 // user_address
    load 76                                                 // timestamp_2
    load 74                                                 // account_power_index_2
    callsub __func__get_cumulative_power_of_at
    store 80                                                // account_cumulative_power_2
    // tl:430: bytes cumulative_power_delta = account_cumulative_power_2 b- account_cumulative_power_1 [slot 81]
    load 80                                                 // account_cumulative_power_2
    load 79                                                 // account_cumulative_power_1
    b-
    store 81                                                // cumulative_power_delta
    // Pad the result to 16 bytes
    // tl:432: return bzero(16) b| cumulative_power_delta
    pushint 16
    bzero
    load 81                                                 // cumulative_power_delta
    b|
    retsub

// tl:436: func get_total_cumulative_power_delta(timestamp_1: int, timestamp_2: int, total_power_index_1: int, total_power_index_2: int) bytes:
__func__get_total_cumulative_power_delta:
    store 82                                                // total_power_index_2 [int]
    store 83                                                // total_power_index_1 [int]
    store 84                                                // timestamp_2 [int]
    store 85                                                // timestamp_1 [int]
    // tl:437: bytes total_cumulative_power_1 = get_total_cumulative_power_at(timestamp_1, total_power_index_1) [slot 86]
    load 85                                                 // timestamp_1
    load 83                                                 // total_power_index_1
    callsub __func__get_total_cumulative_power_at
    store 86                                                // total_cumulative_power_1
    // tl:438: bytes total_cumulative_power_2 = get_total_cumulative_power_at(timestamp_2, total_power_index_2) [slot 87]
    load 84                                                 // timestamp_2
    load 82                                                 // total_power_index_2
    callsub __func__get_total_cumulative_power_at
    store 87                                                // total_cumulative_power_2
    // tl:439: bytes cumulative_power_delta = total_cumulative_power_2 b- total_cumulative_power_1 [slot 88]
    load 87                                                 // total_cumulative_power_2
    load 86                                                 // total_cumulative_power_1
    b-
    store 88                                                // cumulative_power_delta
    // Pad the result to 16 bytes
    // tl:441: return bzero(16) b| cumulative_power_delta
    pushint 16
    bzero
    load 88                                                 // cumulative_power_delta
    b|
    retsub

// tl:445: func get_box(box_name: bytes) bytes, bytes:
__func__get_box:
    store 89                                                // box_name [bytes]
    // tl:446: bytes data [slot 90]
    // tl:447: _, data = box_get(box_name)
    load 89                                                 // box_name
    box_get
    pop                                                     // discarding value for _
    store 90                                                // data
    // Return length as 2 bytes instead of using 8 bytes for uint64
    // tl:449: bytes length = extract(6, 2, itob(len(data))) [slot 91]
    load 90                                                 // data
    len
    itob
    extract 6 2
    store 91                                                // length
    // tl:450: return length, data
    load 90                                                 // data
    load 91                                                 // length
    retsub

// tl:454: func delete_account_power_boxes(box_count: int):
__func__delete_account_power_boxes:
    store 92                                                // box_count [int]
    // tl:455: bytes[32] user_address = Txn.Sender [slot 93]
    txn Sender
    store 93                                                // user_address
    
    // tl:457: box<AccountState> account_state = Box(user_address) [slot 94]
    load 93                                                 // user_address
    store 94                                                // box:account_state
    // tl:458: int account_power_count = account_state.power_count [slot 95]
    load 94; pushint 16; pushint 8; box_extract; btoi// account_state.power_count
    store 95                                                // account_power_count
    // tl:459: int deleted_account_power_count = account_state.deleted_power_count [slot 96]
    load 94; pushint 24; pushint 8; box_extract; btoi// account_state.deleted_power_count
    store 96                                                // deleted_account_power_count
    // tl:460: int account_power_count_to_delete = box_count * ACCOUNT_POWER_BOX_ARRAY_LEN [slot 97]
    load 92                                                 // box_count
    pushint ACCOUNT_POWER_BOX_ARRAY_LEN                     // 21
    *
    store 97                                                // account_power_count_to_delete
    
    // keep at least 1 account power to able to track cumulative power delta
    // tl:463: assert(account_power_count > (deleted_account_power_count + account_power_count_to_delete))
    load 95                                                 // account_power_count
    load 96                                                 // deleted_account_power_count
    load 97                                                 // account_power_count_to_delete
    +
    >
    assert
    // tl:464: account_state.deleted_power_count = deleted_account_power_count + account_power_count_to_delete
    load 96                                                 // deleted_account_power_count
    load 97                                                 // account_power_count_to_delete
    +
    itob; load 94; pushint 24; uncover 2; box_replace// boxset account_state.deleted_power_count
    
    // tl:466: int box_index_start = deleted_account_power_count / ACCOUNT_POWER_BOX_ARRAY_LEN [slot 98]
    load 96                                                 // deleted_account_power_count
    pushint ACCOUNT_POWER_BOX_ARRAY_LEN                     // 21
    /
    store 98                                                // box_index_start
    // tl:467: int box_index_end = box_index_start + box_count [slot 99]
    load 98                                                 // box_index_start
    load 92                                                 // box_count
    +
    store 99                                                // box_index_end
    
    // tl:469: int min_balance_delta = 0 [slot 100]
    pushint 0
    store 100                                               // min_balance_delta
    // tl:470: for i in box_index_start:box_index_end:
        load 98                                             // box_index_start
        store 101                                           // i
        l7_for:
        load 101                                            // i
        load 99                                             // box_index_end
        ==
        bnz l7_end
        // tl:471: min_balance_delta = min_balance_delta + delete_box(Concat(user_address, itob(i)))
        load 100                                            // min_balance_delta
        load 93                                             // user_address
        load 101                                            // i
        itob
        concat
        callsub __func__delete_box
        +
        store 100                                           // min_balance_delta
        load 101                                            // i
        pushint 1
        +
        store 101                                           // i
        b l7_for
        l7_end:
    // tl:473: algo_transfer(min_balance_delta, Global.CurrentApplicationAddress, user_address)
    load 100                                                // min_balance_delta
    global CurrentApplicationAddress
    load 93                                                 // user_address
    callsub __func__algo_transfer
    
    // address, box_index_start, box_count
    // tl:476: log(Concat(method("delete_account_power_boxes(address,uint64,uint64)"), user_address, itob(box_index_start), itob(box_count)))
    method "delete_account_power_boxes(address,uint64,uint64)"
    load 93                                                 // user_address
    load 98                                                 // box_index_start
    itob
    load 92                                                 // box_count
    itob
    concat
    concat
    concat
    log
    // tl:477: return
    retsub

// tl:481: func delete_account_state():
__func__delete_account_state:
    // Deletes remaining AccountPower and the AccountState boxes and returns the min balance Algo
    // tl:483: bytes[32] user_address = Txn.Sender [slot 102]
    txn Sender
    store 102                                               // user_address
    
    // tl:485: box<AccountState> account_state = Box(user_address) [slot 103]
    load 102                                                // user_address
    store 103                                               // box:account_state
    // tl:486: int account_power_count = account_state.power_count [slot 104]
    load 103; pushint 16; pushint 8; box_extract; btoi// account_state.power_count
    store 104                                               // account_power_count
    // Ensure the lock is empty and expired
    // tl:488: assert(!account_state.locked_amount)
    load 103; pushint 0; pushint 8; box_extract; btoi// account_state.locked_amount
    !
    assert
    // tl:489: assert(!account_state.lock_end_time)
    load 103; pushint 8; pushint 8; box_extract; btoi// account_state.lock_end_time
    !
    assert
    
    // tl:491: int deleted_account_power_count = account_state.deleted_power_count [slot 105]
    load 103; pushint 24; pushint 8; box_extract; btoi// account_state.deleted_power_count
    store 105                                               // deleted_account_power_count
    // tl:492: int box_index = deleted_account_power_count / ACCOUNT_POWER_BOX_ARRAY_LEN [slot 106]
    load 105                                                // deleted_account_power_count
    pushint ACCOUNT_POWER_BOX_ARRAY_LEN                     // 21
    /
    store 106                                               // box_index
    // tl:493: int box_count = 0 [slot 107]
    pushint 0
    store 107                                               // box_count
    
    // tl:495: int min_balance_delta = 0 [slot 108]
    pushint 0
    store 108                                               // min_balance_delta
    // tl:496: while account_power_count > deleted_account_power_count:
    l8_while:
        load 104                                            // account_power_count
        load 105                                            // deleted_account_power_count
        >
        bz l8_end
        // delete account power
        // tl:498: min_balance_delta = min_balance_delta + delete_box(Concat(user_address, itob(box_index)))
        load 108                                            // min_balance_delta
        load 102                                            // user_address
        load 106                                            // box_index
        itob
        concat
        callsub __func__delete_box
        +
        store 108                                           // min_balance_delta
        
        // tl:500: box_count = box_count + 1
        load 107                                            // box_count
        pushint 1
        +
        store 107                                           // box_count
        // tl:501: box_index = box_index + 1
        load 106                                            // box_index
        pushint 1
        +
        store 106                                           // box_index
        // tl:502: deleted_account_power_count = deleted_account_power_count + ACCOUNT_POWER_BOX_ARRAY_LEN
        load 105                                            // deleted_account_power_count
        pushint ACCOUNT_POWER_BOX_ARRAY_LEN                 // 21
        +
        store 105                                           // deleted_account_power_count
        b l8_while
        l8_end:
    
    // delete account state
    // tl:506: min_balance_delta = min_balance_delta + delete_box(user_address)
    load 108                                                // min_balance_delta
    load 102                                                // user_address
    callsub __func__delete_box
    +
    store 108                                               // min_balance_delta
    // tl:507: algo_transfer(min_balance_delta, Global.CurrentApplicationAddress, user_address)
    load 108                                                // min_balance_delta
    global CurrentApplicationAddress
    load 102                                                // user_address
    callsub __func__algo_transfer
    
    // address, box_index_start, box_count
    // tl:510: log(Concat(method("delete_account_state(address,uint64,uint64)"), user_address, itob((box_index + 1) - box_count), itob(box_count)))
    method "delete_account_state(address,uint64,uint64)"
    load 102                                                // user_address
    load 106                                                // box_index
    pushint 1
    +
    load 107                                                // box_count
    -
    itob
    load 107                                                // box_count
    itob
    concat
    concat
    concat
    log
    // tl:511: return
    retsub

// tl:514: func construct_account_power(bias: int, timestamp: int, slope: bytes, cumulative_power: bytes) AccountPower:
__func__construct_account_power:
    store 109                                               // cumulative_power [bytes]
    store 110                                               // slope [bytes]
    store 111                                               // timestamp [int]
    store 112                                               // bias [int]
    // tl:515: return Cast(Concat(itob(bias), itob(timestamp), (bzero(16) b| slope), (bzero(16) b| cumulative_power)), AccountPower)
    load 112                                                // bias
    itob
    load 111                                                // timestamp
    itob
    pushint 16
    bzero
    load 110                                                // slope
    b|
    pushint 16
    bzero
    load 109                                                // cumulative_power
    b|
    concat
    concat
    concat
    dup; len; pushint 48; ==; assert// Bytes Size Assertion: 48 bytes
    retsub

// tl:518: func save_account_power(address: bytes[32], index: int, data: AccountPower):
__func__save_account_power:
    store 113                                               // data [AccountPower[48]]
    store 114                                               // index [int]
    store 115                                               // address [bytes[32]]
    // tl:519: int box_index = index / ACCOUNT_POWER_BOX_ARRAY_LEN [slot 116]
    load 114                                                // index
    pushint ACCOUNT_POWER_BOX_ARRAY_LEN                     // 21
    /
    store 116                                               // box_index
    // tl:520: int array_index = index % ACCOUNT_POWER_BOX_ARRAY_LEN [slot 117]
    load 114                                                // index
    pushint ACCOUNT_POWER_BOX_ARRAY_LEN                     // 21
    %
    store 117                                               // array_index
    // tl:521: bytes box_name = Concat(address, itob(box_index)) [slot 118]
    load 115                                                // address
    load 116                                                // box_index
    itob
    concat
    store 118                                               // box_name
    // tl:522: _ = box_create(box_name, ACCOUNT_POWER_BOX_SIZE)
    load 118                                                // box_name
    pushint ACCOUNT_POWER_BOX_SIZE                          // 1008
    box_create
    pop                                                     // discarding value for _
    // tl:523: box_replace(box_name, (array_index * ACCOUNT_POWER_SIZE), data)
    load 118                                                // box_name
    load 117                                                // array_index
    pushint ACCOUNT_POWER_SIZE                              // 48
    *
    load 113                                                // data
    box_replace
    
    // tl:525: log(Concat(method("account_power(address,uint64,uint64,uint64,uint128,uint128)"), address, itob(index), data))
    method "account_power(address,uint64,uint64,uint64,uint128,uint128)"
    load 115                                                // address
    load 114                                                // index
    itob
    load 113                                                // data
    concat
    concat
    concat
    log
    // tl:526: return
    retsub

// tl:529: func get_account_power(address: bytes[32], index: int) AccountPower:
__func__get_account_power:
    store 119                                               // index [int]
    store 120                                               // address [bytes[32]]
    // tl:530: int box_index = index / ACCOUNT_POWER_BOX_ARRAY_LEN [slot 121]
    load 119                                                // index
    pushint ACCOUNT_POWER_BOX_ARRAY_LEN                     // 21
    /
    store 121                                               // box_index
    // tl:531: int array_index = index % ACCOUNT_POWER_BOX_ARRAY_LEN [slot 122]
    load 119                                                // index
    pushint ACCOUNT_POWER_BOX_ARRAY_LEN                     // 21
    %
    store 122                                               // array_index
    // tl:532: bytes box_name = Concat(address, itob(box_index)) [slot 123]
    load 120                                                // address
    load 121                                                // box_index
    itob
    concat
    store 123                                               // box_name
    // tl:533: return Cast(box_extract(box_name, (array_index * ACCOUNT_POWER_SIZE), ACCOUNT_POWER_SIZE), AccountPower)
    load 123                                                // box_name
    load 122                                                // array_index
    pushint ACCOUNT_POWER_SIZE                              // 48
    *
    pushint ACCOUNT_POWER_SIZE                              // 48
    box_extract
    dup; len; pushint 48; ==; assert// Bytes Size Assertion: 48 bytes
    retsub

// tl:536: func construct_total_power(bias: int, timestamp: int, slope: bytes, cumulative_power: bytes) TotalPower:
__func__construct_total_power:
    store 124                                               // cumulative_power [bytes]
    store 125                                               // slope [bytes]
    store 126                                               // timestamp [int]
    store 127                                               // bias [int]
    // tl:537: return Cast(Concat(itob(bias), itob(timestamp), (bzero(16) b| slope), (bzero(16) b| cumulative_power)), TotalPower)
    load 127                                                // bias
    itob
    load 126                                                // timestamp
    itob
    pushint 16
    bzero
    load 125                                                // slope
    b|
    pushint 16
    bzero
    load 124                                                // cumulative_power
    b|
    concat
    concat
    concat
    dup; len; pushint 48; ==; assert// Bytes Size Assertion: 48 bytes
    retsub

// tl:540: func save_total_power(data: TotalPower):
__func__save_total_power:
    store 128                                               // data [TotalPower[48]]
    // tl:541: int index = app_global_get(TOTAL_POWER_COUNT_KEY) [slot 129]
    pushbytes TOTAL_POWER_COUNT_KEY                         // "total_power_count"
    app_global_get
    store 129                                               // index
    // tl:542: int box_index = index / TOTAL_POWER_BOX_ARRAY_LEN [slot 130]
    load 129                                                // index
    pushint TOTAL_POWER_BOX_ARRAY_LEN                       // 21
    /
    store 130                                               // box_index
    // tl:543: int array_index = index % TOTAL_POWER_BOX_ARRAY_LEN [slot 131]
    load 129                                                // index
    pushint TOTAL_POWER_BOX_ARRAY_LEN                       // 21
    %
    store 131                                               // array_index
    // tl:544: bytes box_name = Concat(TOTAL_POWER_BOX_PREFIX, itob(box_index)) [slot 132]
    pushbytes TOTAL_POWER_BOX_PREFIX                        // "tp"
    load 130                                                // box_index
    itob
    concat
    store 132                                               // box_name
    // tl:545: _ = box_create(box_name, TOTAL_POWER_BOX_SIZE)
    load 132                                                // box_name
    pushint TOTAL_POWER_BOX_SIZE                            // 1008
    box_create
    pop                                                     // discarding value for _
    // tl:546: box_replace(box_name, (array_index * TOTAL_POWER_SIZE), data)
    load 132                                                // box_name
    load 131                                                // array_index
    pushint TOTAL_POWER_SIZE                                // 48
    *
    load 128                                                // data
    box_replace
    
    // tl:548: log(Concat(method("total_power(uint64,uint64,uint64,uint128,uint128)"), itob(index), data))
    method "total_power(uint64,uint64,uint64,uint128,uint128)"
    load 129                                                // index
    itob
    load 128                                                // data
    concat
    concat
    log
    // tl:549: app_global_put(TOTAL_POWER_COUNT_KEY, index + 1)
    pushbytes TOTAL_POWER_COUNT_KEY                         // "total_power_count"
    load 129                                                // index
    pushint 1
    +
    app_global_put
    // tl:550: app_global_put(LAST_TOTAL_POWER_TIMESTAMP, extract_uint64(data, 8))
    pushbytes LAST_TOTAL_POWER_TIMESTAMP                    // "last_total_power_timestamp"
    load 128                                                // data
    pushint 8
    extract_uint64
    app_global_put
    // tl:551: return
    retsub

// tl:554: func get_total_power(index: int) TotalPower:
__func__get_total_power:
    store 133                                               // index [int]
    // tl:555: int box_index = index / TOTAL_POWER_BOX_ARRAY_LEN [slot 134]
    load 133                                                // index
    pushint TOTAL_POWER_BOX_ARRAY_LEN                       // 21
    /
    store 134                                               // box_index
    // tl:556: int array_index = index % TOTAL_POWER_BOX_ARRAY_LEN [slot 135]
    load 133                                                // index
    pushint TOTAL_POWER_BOX_ARRAY_LEN                       // 21
    %
    store 135                                               // array_index
    // tl:557: bytes box_name = Concat(TOTAL_POWER_BOX_PREFIX, itob(box_index)) [slot 136]
    pushbytes TOTAL_POWER_BOX_PREFIX                        // "tp"
    load 134                                                // box_index
    itob
    concat
    store 136                                               // box_name
    // tl:558: return Cast(box_extract(box_name, (array_index * TOTAL_POWER_SIZE), TOTAL_POWER_SIZE), TotalPower)
    load 136                                                // box_name
    load 135                                                // array_index
    pushint TOTAL_POWER_SIZE                                // 48
    *
    pushint TOTAL_POWER_SIZE                                // 48
    box_extract
    dup; len; pushint 48; ==; assert// Bytes Size Assertion: 48 bytes
    retsub

// tl:562: func get_cumulative_power_of_at(user_address: bytes[32], timestamp: int, account_power_index: int) bytes:
__func__get_cumulative_power_of_at:
    store 137                                               // account_power_index [int]
    store 138                                               // timestamp [int]
    store 139                                               // user_address [bytes[32]]
    // Calculates the cumulative power of a user at a specific timestamp in the past
    // tl:564: bytes cumulative_power [slot 140]
    // tl:565: assert(timestamp <= Global.LatestTimestamp)
    load 138                                                // timestamp
    global LatestTimestamp
    <=
    assert
    
    // tl:567: bytes cumulative_power_delta [slot 141]
    // tl:568: int exists [slot 142]
    // tl:569: exists, _ = box_len(user_address)
    load 139                                                // user_address
    box_len
    store 142                                               // exists
    pop                                                     // discarding value for _
    // tl:570: if exists:
    load 142                                                // exists
    bz l9_end
    // then:
        // tl:571: box<AccountState> account_state = Box(user_address) [slot 143]
        load 139                                            // user_address
        store 143                                           // box:account_state
        // tl:572: assert(account_power_index < account_state.power_count)
        load 137                                            // account_power_index
        load 143; pushint 16; pushint 8; box_extract; btoi// account_state.power_count
        <
        assert
        
        // account_power.timestamp <= timestamp < next_account_power.timestamp
        // tl:575: AccountPower account_power = get_account_power(user_address, account_power_index) [slot 144]
        load 139                                            // user_address
        load 137                                            // account_power_index
        callsub __func__get_account_power
        store 144                                           // account_power
        // tl:576: if account_power.timestamp <= timestamp:
        load 144; extract 8 8; btoi// account_power.timestamp
        load 138                                            // timestamp
        <=
        bz l10_else
        // then:
            // assert(timestamp > account_power.timestamp)
            // tl:578: if (account_power_index + 1) < account_state.power_count:
            load 137                                        // account_power_index
            pushint 1
            +
            load 143; pushint 16; pushint 8; box_extract; btoi// account_state.power_count
            <
            bz l11_end
            // then:
                // tl:579: AccountPower next_account_power = get_account_power(user_address, account_power_index + 1) [slot 145]
                load 139                                    // user_address
                load 137                                    // account_power_index
                pushint 1
                +
                callsub __func__get_account_power
                store 145                                   // next_account_power
                // tl:580: assert(timestamp < next_account_power.timestamp)
                load 138                                    // timestamp
                load 145; extract 8 8; btoi// next_account_power.timestamp
                <
                assert
            l11_end:
            
            // tl:583: int time_delta = timestamp - account_power.timestamp [slot 146]
            load 138                                        // timestamp
            load 144; extract 8 8; btoi// account_power.timestamp
            -
            store 146                                       // time_delta
            // tl:584: int bias_delta = get_bias(account_power.slope, time_delta) [slot 147]
            load 144; extract 16 16// account_power.slope
            load 146                                        // time_delta
            callsub __func__get_bias
            store 147                                       // bias_delta
            // tl:585: if bias_delta < account_power.bias:
            load 147                                        // bias_delta
            load 144; extract 0 8; btoi// account_power.bias
            <
            bz l12_else
            // then:
                // tl:586: cumulative_power_delta = get_cumulative_power_1(account_power.bias, (account_power.bias - bias_delta), time_delta)
                load 144; extract 0 8; btoi// account_power.bias
                load 144; extract 0 8; btoi// account_power.bias
                load 147                                    // bias_delta
                -
                load 146                                    // time_delta
                callsub __func__get_cumulative_power_1
                store 141                                   // cumulative_power_delta
                b l12_end
            l12_else:
            // tl:587: else:
                // tl:588: cumulative_power_delta = get_cumulative_power_2(account_power.bias, account_power.slope)
                load 144; extract 0 8; btoi// account_power.bias
                load 144; extract 16 16// account_power.slope
                callsub __func__get_cumulative_power_2
                store 141                                   // cumulative_power_delta
            l12_end:
            
            // tl:591: cumulative_power = bzero(16) b| (account_power.cumulative_power b+ cumulative_power_delta)
            pushint 16
            bzero
            load 144; extract 32 16// account_power.cumulative_power
            load 141                                        // cumulative_power_delta
            b+
            b|
            store 140                                       // cumulative_power
            b l10_end
        l10_else:
        // tl:592: else:
            // Index must be 0, it indicates that the given timestamp predates the first checkpoint.
            // tl:594: assert(!account_power_index)
            load 137                                        // account_power_index
            !
            assert
            // tl:595: cumulative_power = bzero(16)
            pushint 16
            bzero
            store 140                                       // cumulative_power
        l10_end:
    l9_end:
    
    // tl:599: return cumulative_power
    load 140                                                // cumulative_power
    retsub

// tl:603: func get_total_cumulative_power_at(timestamp: int, total_power_index: int) bytes:
__func__get_total_cumulative_power_at:
    store 148                                               // total_power_index [int]
    store 149                                               // timestamp [int]
    // Calculates the cumulative total power at a specific timestamp in the past
    // tl:605: bytes total_cumulative_power [slot 150]
    // tl:606: assert(total_power_index < app_global_get(TOTAL_POWER_COUNT_KEY))
    load 148                                                // total_power_index
    pushbytes TOTAL_POWER_COUNT_KEY                         // "total_power_count"
    app_global_get
    <
    assert
    // tl:607: assert(timestamp <= Global.LatestTimestamp)
    load 149                                                // timestamp
    global LatestTimestamp
    <=
    assert
    
    // tl:609: bytes cumulative_power_delta [slot 151]
    // tl:610: TotalPower total_power = get_total_power(total_power_index) [slot 152]
    load 148                                                // total_power_index
    callsub __func__get_total_power
    store 152                                               // total_power
    
    // tl:612: if total_power.timestamp <= timestamp:
    load 152; extract 8 8; btoi// total_power.timestamp
    load 149                                                // timestamp
    <=
    bz l13_else
    // then:
        // tl:613: if (total_power_index + 1) < app_global_get(TOTAL_POWER_COUNT_KEY):
        load 148                                            // total_power_index
        pushint 1
        +
        pushbytes TOTAL_POWER_COUNT_KEY                     // "total_power_count"
        app_global_get
        <
        bz l14_end
        // then:
            // tl:614: TotalPower next_total_power = get_total_power(total_power_index + 1) [slot 153]
            load 148                                        // total_power_index
            pushint 1
            +
            callsub __func__get_total_power
            store 153                                       // next_total_power
            // tl:615: assert(timestamp < next_total_power.timestamp)
            load 149                                        // timestamp
            load 153; extract 8 8; btoi// next_total_power.timestamp
            <
            assert
        l14_end:
        
        // Ensure that the latest checkpoint belongs to the same week so the slope is not changed.
        // tl:619: assert((total_power.timestamp / WEEK) == (timestamp / WEEK))
        load 152; extract 8 8; btoi// total_power.timestamp
        pushint WEEK                                        // 604800
        /
        load 149                                            // timestamp
        pushint WEEK                                        // 604800
        /
        ==
        assert
        
        // tl:621: int time_delta = timestamp - total_power.timestamp [slot 154]
        load 149                                            // timestamp
        load 152; extract 8 8; btoi// total_power.timestamp
        -
        store 154                                           // time_delta
        // tl:622: int bias_delta = get_bias(total_power.slope, time_delta) [slot 155]
        load 152; extract 16 16// total_power.slope
        load 154                                            // time_delta
        callsub __func__get_bias
        store 155                                           // bias_delta
        // tl:623: if bias_delta < total_power.bias:
        load 155                                            // bias_delta
        load 152; extract 0 8; btoi// total_power.bias
        <
        bz l15_else
        // then:
            // tl:624: cumulative_power_delta = get_cumulative_power_1(total_power.bias, (total_power.bias - bias_delta), time_delta)
            load 152; extract 0 8; btoi// total_power.bias
            load 152; extract 0 8; btoi// total_power.bias
            load 155                                        // bias_delta
            -
            load 154                                        // time_delta
            callsub __func__get_cumulative_power_1
            store 151                                       // cumulative_power_delta
            b l15_end
        l15_else:
        // tl:625: else:
            // tl:626: cumulative_power_delta = get_cumulative_power_2(total_power.bias, total_power.slope)
            load 152; extract 0 8; btoi// total_power.bias
            load 152; extract 16 16// total_power.slope
            callsub __func__get_cumulative_power_2
            store 151                                       // cumulative_power_delta
        l15_end:
        
        // tl:629: total_cumulative_power = bzero(16) b| (total_power.cumulative_power b+ cumulative_power_delta)
        pushint 16
        bzero
        load 152; extract 32 16// total_power.cumulative_power
        load 151                                            // cumulative_power_delta
        b+
        b|
        store 150                                           // total_cumulative_power
        b l13_end
    l13_else:
    // tl:630: else:
        // Index must be 0, it indicates that the given timestamp predates the first checkpoint.
        // tl:632: assert(!total_power_index)
        load 148                                            // total_power_index
        !
        assert
        // tl:633: total_cumulative_power = bzero(16)
        pushint 16
        bzero
        store 150                                           // total_cumulative_power
    l13_end:
    
    // tl:636: return total_cumulative_power
    load 150                                                // total_cumulative_power
    retsub

// tl:639: func create_checkpoints_internal(account_bias_delta: int, account_slope_delta: bytes, has_account_event: int):
__func__create_checkpoints_internal:
    store 156                                               // has_account_event [int]
    store 157                                               // account_slope_delta [bytes]
    store 158                                               // account_bias_delta [int]
    // https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L234
    
    // tl:642: TotalPower last_total_power = get_total_power(app_global_get(TOTAL_POWER_COUNT_KEY) - 1) [slot 159]
    pushbytes TOTAL_POWER_COUNT_KEY                         // "total_power_count"
    app_global_get
    pushint 1
    -
    callsub __func__get_total_power
    store 159                                               // last_total_power
    
    // tl:644: int bias = last_total_power.bias [slot 160]
    load 159; extract 0 8; btoi// last_total_power.bias
    store 160                                               // bias
    // tl:645: bytes slope = last_total_power.slope [slot 161]
    load 159; extract 16 16// last_total_power.slope
    store 161                                               // slope
    // tl:646: bytes cumulative_power = last_total_power.cumulative_power [slot 162]
    load 159; extract 32 16// last_total_power.cumulative_power
    store 162                                               // cumulative_power
    
    // tl:648: int last_checkpoint_timestamp = last_total_power.timestamp [slot 163]
    load 159; extract 8 8; btoi// last_total_power.timestamp
    store 163                                               // last_checkpoint_timestamp
    // tl:649: int temp_checkpoint_timestamp = (last_checkpoint_timestamp / WEEK) * WEEK [slot 164]
    load 163                                                // last_checkpoint_timestamp
    pushint WEEK                                            // 604800
    /
    pushint WEEK                                            // 604800
    *
    store 164                                               // temp_checkpoint_timestamp
    
    // tl:651: bytes slope_delta [slot 165]
    // tl:652: int bias_delta [slot 166]
    // tl:653: int time_delta [slot 167]
    
    // tl:655: int i = 0 [slot 168]
    pushint 0
    store 168                                               // i
    // tl:656: int stop = 9 [slot 169]
    pushint 9
    store 169                                               // stop
    // tl:657: while i < stop:
    l16_while:
        load 168                                            // i
        load 169                                            // stop
        <
        bz l16_end
        // tl:658: temp_checkpoint_timestamp = temp_checkpoint_timestamp + WEEK
        load 164                                            // temp_checkpoint_timestamp
        pushint WEEK                                        // 604800
        +
        store 164                                           // temp_checkpoint_timestamp
        // tl:659: slope_delta = itob(0)
        pushint 0
        itob
        store 165                                           // slope_delta
        
        // tl:661: if temp_checkpoint_timestamp > Global.LatestTimestamp:
        load 164                                            // temp_checkpoint_timestamp
        global LatestTimestamp
        >
        bz l17_end
        // then:
            // tl:662: temp_checkpoint_timestamp = Global.LatestTimestamp
            global LatestTimestamp
            store 164                                       // temp_checkpoint_timestamp
        l17_end:
        
        // If it is a new week, get the slope_delta from the slope_change box.
        // tl:666: if !(temp_checkpoint_timestamp % WEEK):
        load 164                                            // temp_checkpoint_timestamp
        pushint WEEK                                        // 604800
        %
        !
        bz l18_end
        // then:
            // tl:667: _, slope_delta = box_get(Concat(SLOPE_CHANGE_BOX_PREFIX, itob(temp_checkpoint_timestamp)))
            pushbytes SLOPE_CHANGE_BOX_PREFIX               // "sc"
            load 164                                        // temp_checkpoint_timestamp
            itob
            concat
            box_get
            pop                                             // discarding value for _
            store 165                                       // slope_delta
        l18_end:
        
        // tl:670: time_delta = temp_checkpoint_timestamp - last_checkpoint_timestamp
        load 164                                            // temp_checkpoint_timestamp
        load 163                                            // last_checkpoint_timestamp
        -
        store 167                                           // time_delta
        // tl:671: bias_delta = get_bias(slope, time_delta)
        load 161                                            // slope
        load 167                                            // time_delta
        callsub __func__get_bias
        store 166                                           // bias_delta
        
        // tl:673: if bias_delta > bias:
        load 166                                            // bias_delta
        load 160                                            // bias
        >
        bz l19_else
        // then:
            // tl:674: cumulative_power = cumulative_power b+ get_cumulative_power_2(bias, slope)
            load 162                                        // cumulative_power
            load 160                                        // bias
            load 161                                        // slope
            callsub __func__get_cumulative_power_2
            b+
            store 162                                       // cumulative_power
            // tl:675: slope = bzero(16)
            pushint 16
            bzero
            store 161                                       // slope
            // tl:676: bias = 0
            pushint 0
            store 160                                       // bias
            b l19_end
        l19_else:
        // tl:677: else:
            // tl:678: cumulative_power = cumulative_power b+ get_cumulative_power_1(bias, (bias - bias_delta), time_delta)
            load 162                                        // cumulative_power
            load 160                                        // bias
            load 160                                        // bias
            load 166                                        // bias_delta
            -
            load 167                                        // time_delta
            callsub __func__get_cumulative_power_1
            b+
            store 162                                       // cumulative_power
            // tl:679: bias = bias - bias_delta
            load 160                                        // bias
            load 166                                        // bias_delta
            -
            store 160                                       // bias
        l19_end:
        
        // tl:682: if slope_delta b>= slope:
        load 165                                            // slope_delta
        load 161                                            // slope
        b>=
        bz l20_else
        // then:
            // tl:683: slope = bzero(16)
            pushint 16
            bzero
            store 161                                       // slope
            // tl:684: bias = 0
            pushint 0
            store 160                                       // bias
            b l20_end
        l20_else:
        // tl:685: else:
            // tl:686: slope = slope b- slope_delta
            load 161                                        // slope
            load 165                                        // slope_delta
            b-
            store 161                                       // slope
        l20_end:
        
        // tl:689: last_checkpoint_timestamp = temp_checkpoint_timestamp
        load 164                                            // temp_checkpoint_timestamp
        store 163                                           // last_checkpoint_timestamp
        
        // If it has arrived to the current time, break the loop.
        // tl:692: if temp_checkpoint_timestamp == Global.LatestTimestamp:
        load 164                                            // temp_checkpoint_timestamp
        global LatestTimestamp
        ==
        bz l21_else
        // then:
            // tl:693: i = stop
            load 169                                        // stop
            store 168                                       // i
            // tl:694: if has_account_event:
            load 156                                        // has_account_event
            bz l22_else
            // then:
                // tl:695: save_total_power(construct_total_power(bias + account_bias_delta, last_checkpoint_timestamp, slope b+ account_slope_delta, cumulative_power))
                load 160                                    // bias
                load 158                                    // account_bias_delta
                +
                load 163                                    // last_checkpoint_timestamp
                load 161                                    // slope
                load 157                                    // account_slope_delta
                b+
                load 162                                    // cumulative_power
                callsub __func__construct_total_power
                callsub __func__save_total_power
                b l22_end
            l22_else:
            // tl:696: else:
                // tl:697: save_total_power(construct_total_power(bias, last_checkpoint_timestamp, slope, cumulative_power))
                load 160                                    // bias
                load 163                                    // last_checkpoint_timestamp
                load 161                                    // slope
                load 162                                    // cumulative_power
                callsub __func__construct_total_power
                callsub __func__save_total_power
            l22_end:
            b l21_end
        l21_else:
        // tl:699: else:
            // tl:700: i = i + 1
            load 168                                        // i
            pushint 1
            +
            store 168                                       // i
            // tl:701: save_total_power(construct_total_power(bias, last_checkpoint_timestamp, slope, cumulative_power))
            load 160                                        // bias
            load 163                                        // last_checkpoint_timestamp
            load 161                                        // slope
            load 162                                        // cumulative_power
            callsub __func__construct_total_power
            callsub __func__save_total_power
        l21_end:
        b l16_while
        l16_end:
    // tl:704: assert(!(has_account_event && (temp_checkpoint_timestamp != Global.LatestTimestamp)))
    load 156                                                // has_account_event
    load 164                                                // temp_checkpoint_timestamp
    global LatestTimestamp
    !=
    &&
    !
    assert
    // tl:705: return
    retsub

// tl:708: func get_cumulative_power_1(old_bias: int, new_bias: int, time_delta: int) bytes:
__func__get_cumulative_power_1:
    store 170                                               // time_delta [int]
    store 171                                               // new_bias [int]
    store 172                                               // old_bias [int]
    // (old_bias + new_bias) * time_delta / 2
    // tl:710: return ((itob(old_bias) b+ itob(new_bias)) b* itob(time_delta)) b/ itob(2)
    load 172                                                // old_bias
    itob
    load 171                                                // new_bias
    itob
    b+
    load 170                                                // time_delta
    itob
    b*
    pushint 2
    itob
    b/
    retsub

// tl:713: func get_cumulative_power_2(old_bias: int, slope: bytes) bytes:
__func__get_cumulative_power_2:
    store 173                                               // slope [bytes]
    store 174                                               // old_bias [int]
    // time_delta = old_bias / slope
    // (old_bias + new_bias) * (old_bias / slope) / 2, new_bias = 0
    // (old_bias * old_bias) / (slope * 2)
    // tl:717: if slope != bzero(16):
    load 173                                                // slope
    pushint 16
    bzero
    !=
    bz l23_end
    // then:
        // tl:718: return ((itob(old_bias) b* itob(old_bias)) b* TWO_TO_THE_64) b/ (slope b* itob(2))
        load 174                                            // old_bias
        itob
        load 174                                            // old_bias
        itob
        b*
        pushbytes TWO_TO_THE_64                             // "\x01\x00\x00\x00\x00\x00\x00\x00\x00"
        b*
        load 173                                            // slope
        pushint 2
        itob
        b*
        b/
        retsub
    l23_end:
    // tl:720: return bzero(16)
    pushint 16
    bzero
    retsub

// tl:723: func get_bias(slope: bytes, time: int) int:
__func__get_bias:
    store 175                                               // time [int]
    store 176                                               // slope [bytes]
    // 87bits * 32bits / 64bit = 55bits
    // (11bytes * 4bytes) / 8bytes = 7bytes
    // tl:726: return btoi((slope b* itob(time)) b/ TWO_TO_THE_64)
    load 176                                                // slope
    load 175                                                // time
    itob
    b*
    pushbytes TWO_TO_THE_64                                 // "\x01\x00\x00\x00\x00\x00\x00\x00\x00"
    b/
    btoi
    retsub

// tl:729: func get_slope(locked_amount: int) bytes:
__func__get_slope:
    store 177                                               // locked_amount [int]
    // max locked_amount = total supply = 1e15 = 50bits = 7bytes
    // (50bits * 64bits) / 27bits = 87 bits = 11bytes
    // tl:732: return (itob(locked_amount) b* TWO_TO_THE_64) b/ itob(MAX_LOCK_TIME)
    load 177                                                // locked_amount
    itob
    pushbytes TWO_TO_THE_64                                 // "\x01\x00\x00\x00\x00\x00\x00\x00\x00"
    b*
    pushint MAX_LOCK_TIME                                   // 125798400
    itob
    b/
    retsub

// tl:735: func revert_slope_change(timestamp: int, slope: bytes):
__func__revert_slope_change:
    store 178                                               // slope [bytes]
    store 179                                               // timestamp [int]
    // tl:736: bytes box_name = Concat(SLOPE_CHANGE_BOX_PREFIX, itob(timestamp)) [slot 180]
    pushbytes SLOPE_CHANGE_BOX_PREFIX                       // "sc"
    load 179                                                // timestamp
    itob
    concat
    store 180                                               // box_name
    // tl:737: bytes new_slope = bzero(16) b| (box_extract(box_name, 0, 16) b- slope) [slot 181]
    pushint 16
    bzero
    load 180                                                // box_name
    pushint 0
    pushint 16
    box_extract
    load 178                                                // slope
    b-
    b|
    store 181                                               // new_slope
    // tl:738: box_put(box_name, new_slope)
    load 180                                                // box_name
    load 181                                                // new_slope
    box_put
    
    // tl:740: log(Concat(method("slope_change(uint64,uint128)"), itob(timestamp), new_slope))
    method "slope_change(uint64,uint128)"
    load 179                                                // timestamp
    itob
    load 181                                                // new_slope
    concat
    concat
    log
    // tl:741: return
    retsub

// tl:744: func update_or_create_slope_change(timestamp: int, slope: bytes):
__func__update_or_create_slope_change:
    store 182                                               // slope [bytes]
    store 183                                               // timestamp [int]
    // tl:745: bytes box_name = Concat(SLOPE_CHANGE_BOX_PREFIX, itob(timestamp)) [slot 184]
    pushbytes SLOPE_CHANGE_BOX_PREFIX                       // "sc"
    load 183                                                // timestamp
    itob
    concat
    store 184                                               // box_name
    // tl:746: bytes slope_delta [slot 185]
    // tl:747: _, slope_delta = box_get(box_name)
    load 184                                                // box_name
    box_get
    pop                                                     // discarding value for _
    store 185                                               // slope_delta
    // tl:748: bytes new_slope = bzero(16) b| (slope_delta b+ slope) [slot 186]
    pushint 16
    bzero
    load 185                                                // slope_delta
    load 182                                                // slope
    b+
    b|
    store 186                                               // new_slope
    // tl:749: box_put(box_name, new_slope)
    load 184                                                // box_name
    load 186                                                // new_slope
    box_put
    
    // tl:751: log(Concat(method("slope_change(uint64,uint128)"), itob(timestamp), new_slope))
    method "slope_change(uint64,uint128)"
    load 183                                                // timestamp
    itob
    load 186                                                // new_slope
    concat
    concat
    log
    // tl:752: return
    retsub

// tl:755: func get_power(bias: int, slope: bytes, time_delta: int) int:
__func__get_power:
    store 187                                               // time_delta [int]
    store 188                                               // slope [bytes]
    store 189                                               // bias [int]
    // tl:756: int bias_delta = get_bias(slope, time_delta) [slot 190]
    load 188                                                // slope
    load 187                                                // time_delta
    callsub __func__get_bias
    store 190                                               // bias_delta
    // tl:757: if bias_delta < bias:
    load 190                                                // bias_delta
    load 189                                                // bias
    <
    bz l24_end
    // then:
        // tl:758: return bias - bias_delta
        load 189                                            // bias
        load 190                                            // bias_delta
        -
        retsub
    l24_end:
    // tl:760: return 0
    pushint 0
    retsub

// tl:763: func increase_total_locked_amount(amount: int):
__func__increase_total_locked_amount:
    store 191                                               // amount [int]
    // tl:764: app_global_put(TOTAL_LOCKED_AMOUNT_KEY, app_global_get(TOTAL_LOCKED_AMOUNT_KEY) + amount)
    pushbytes TOTAL_LOCKED_AMOUNT_KEY                       // "total_locked_amount"
    pushbytes TOTAL_LOCKED_AMOUNT_KEY                       // "total_locked_amount"
    app_global_get
    load 191                                                // amount
    +
    app_global_put
    // tl:765: return
    retsub

// tl:768: func decrease_total_locked_amount(amount: int):
__func__decrease_total_locked_amount:
    store 192                                               // amount [int]
    // tl:769: app_global_put(TOTAL_LOCKED_AMOUNT_KEY, app_global_get(TOTAL_LOCKED_AMOUNT_KEY) - amount)
    pushbytes TOTAL_LOCKED_AMOUNT_KEY                       // "total_locked_amount"
    pushbytes TOTAL_LOCKED_AMOUNT_KEY                       // "total_locked_amount"
    app_global_get
    load 192                                                // amount
    -
    app_global_put
    // tl:770: return
    retsub

// tl:773: func get_received_tiny_amount() int:
__func__get_received_tiny_amount:
    // this function is designed to retrieve the amount of 'TINY' tokens that have been transferred from a user's account to the contract's account.
    // the asset transfer transaction must be positioned at the -1 index in the transaction group.
    
    // tl:777: assert(Txn.GroupIndex)
    txn GroupIndex
    assert
    // tl:778: int input_txn_index = Txn.GroupIndex - 1 [slot 193]
    txn GroupIndex
    pushint 1
    -
    store 193                                               // input_txn_index
    // tl:779: assert(Gtxn[input_txn_index].Sender == Txn.Sender)
    load 193                                                // input_txn_index
    gtxns Sender
    txn Sender
    ==
    assert
    // tl:780: assert(Gtxn[input_txn_index].TypeEnum == Axfer)
    load 193                                                // input_txn_index
    gtxns TypeEnum
    pushint 4                                               // Axfer
    ==
    assert
    // tl:781: assert(Gtxn[input_txn_index].AssetReceiver == Global.CurrentApplicationAddress)
    load 193                                                // input_txn_index
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    assert
    // tl:782: assert(Gtxn[input_txn_index].XferAsset == app_global_get(TINY_ASSET_ID_KEY))
    load 193                                                // input_txn_index
    gtxns XferAsset
    pushbytes TINY_ASSET_ID_KEY                             // "tiny_asset_id"
    app_global_get
    ==
    assert
    // tl:783: return Gtxn[input_txn_index].AssetAmount
    load 193                                                // input_txn_index
    gtxns AssetAmount
    retsub

// tl:786: func delete_box(box_name: bytes) int:
__func__delete_box:
    store 194                                               // box_name [bytes]
    // tl:787: int initial_min_balance = min_balance(Global.CurrentApplicationAddress) [slot 195]
    global CurrentApplicationAddress
    min_balance
    store 195                                               // initial_min_balance
    // tl:788: assert(box_del(box_name))
    load 194                                                // box_name
    box_del
    assert
    // tl:789: int final_min_balance = min_balance(Global.CurrentApplicationAddress) [slot 196]
    global CurrentApplicationAddress
    min_balance
    store 196                                               // final_min_balance
    // tl:790: int min_balance_delta = initial_min_balance - final_min_balance [slot 197]
    load 195                                                // initial_min_balance
    load 196                                                // final_min_balance
    -
    store 197                                               // min_balance_delta
    
    // tl:792: log(Concat(method("box_del(byte[])"), extract(6, 2, itob(len(box_name))), box_name))
    method "box_del(byte[])"
    load 194                                                // box_name
    len
    itob
    extract 6 2
    load 194                                                // box_name
    concat
    concat
    log
    // tl:793: return min_balance_delta
    load 197                                                // min_balance_delta
    retsub

// tl:796: func algo_transfer(amount: int, sender: bytes, receiver: bytes):
__func__algo_transfer:
    store 198                                               // receiver [bytes]
    store 199                                               // sender [bytes]
    store 200                                               // amount [int]
    // tl:797: inner_txn:
    callsub _itxn_begin
        // tl:798: TypeEnum: Pay
        pushint 1                                           // Pay
        itxn_field TypeEnum
        // tl:799: Sender: sender
        load 199                                            // sender
        itxn_field Sender
        // tl:800: Receiver: receiver
        load 198                                            // receiver
        itxn_field Receiver
        // tl:801: Amount: amount
        load 200                                            // amount
        itxn_field Amount
        // tl:802: Fee: 0
        pushint 0
        itxn_field Fee
    callsub _itxn_submit
    // end inner_txn
    // tl:804: return
    retsub

// tl:807: func tiny_transfer(amount: int, sender: bytes, receiver: bytes):
__func__tiny_transfer:
    store 201                                               // receiver [bytes]
    store 202                                               // sender [bytes]
    store 203                                               // amount [int]
    // tl:808: inner_txn:
    callsub _itxn_begin
        // tl:809: TypeEnum: Axfer
        pushint 4                                           // Axfer
        itxn_field TypeEnum
        // tl:810: Sender: sender
        load 202                                            // sender
        itxn_field Sender
        // tl:811: AssetReceiver: receiver
        load 201                                            // receiver
        itxn_field AssetReceiver
        // tl:812: AssetAmount: amount
        load 203                                            // amount
        itxn_field AssetAmount
        // tl:813: XferAsset: app_global_get(TINY_ASSET_ID_KEY)
        pushbytes TINY_ASSET_ID_KEY                         // "tiny_asset_id"
        app_global_get
        itxn_field XferAsset
        // tl:814: Fee: 0
        pushint 0
        itxn_field Fee
    callsub _itxn_submit
    // end inner_txn
    // tl:816: return
    retsub


_itxn_group_begin:
  load 204; !; assert                                       // ensure no group active
  int 1; store 204; retsub                                  // set group flag

_itxn_begin:
  load 204
  switch _itxn_begin__0 _itxn_begin__1 _itxn_begin__2
  err
  _itxn_begin__0: itxn_begin; retsub                        // no group
  _itxn_begin__1: itxn_begin; int 2; store 204; retsub      // start first txn of group
  _itxn_begin__2: itxn_next; retsub                         // start next txn of group

_itxn_submit:
  load 204
  bz _itxn_submit__0
  retsub                                                    // in a group, don't submit
  _itxn_submit__0: itxn_submit; retsub                      // no group, submit

_itxn_group_submit:
  itxn_submit
  int 0; store 204; retsub                                  // set group flag to 0

