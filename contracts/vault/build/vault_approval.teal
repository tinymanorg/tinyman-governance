#pragma version 9
//tealish version git+https://github.com/Hipo/tealish.git@c4f8c12b36dbcc8b63844df5f818164925735087

// Name: <address>
// Size: 32 bytes

// Name: <address><box_index><array_index>
// Size: 48 bytes (8+8+16+16). 1 Box(1008) = 21 AccountPower

// Name: tp<box_index><array_index>
// Size: 48 bytes (8+8+16+16). 1 Box(1008) = 21 TotalPower

// sc<timestamp>
// 16 bytes

// 7 * DAY
#define WEEK 604800
// 4 * 365 * DAY
#define MAX_LOCK_TIME 126144000
#define MIN_LOCK_AMOUNT 10000000
#define MIN_LOCK_AMOUNT_INCREMENT 10000000
#define TWO_TO_THE_64 "\x01\x00\x00\x00\x00\x00\x00\x00\x00"

// Boxes
#define TOTAL_POWER_BOX_PREFIX "tp"
#define TOTAL_POWER_SIZE 48
#define TOTAL_POWER_BOX_SIZE 1008
#define TOTAL_POWER_BOX_ARRAY_LEN 21

#define ACCOUNT_STATE_SIZE 32

#define ACCOUNT_POWER_SIZE 48
#define ACCOUNT_POWER_BOX_SIZE 1008
#define ACCOUNT_POWER_BOX_ARRAY_LEN 21

#define SLOPE_CHANGE_BOX_PREFIX "sc"
#define SLOPE_CHANGE_SIZE 16

// Keys
#define TINY_ASSET_ID_KEY "tiny_asset_id"
#define TOTAL_LOCKED_AMOUNT_KEY "total_locked_amount"
#define TOTAL_POWER_COUNT_KEY "total_power_count"
#define LAST_TOTAL_POWER_TIMESTAMP "last_total_power_timestamp"


// tl:67: router:
pushbytes "create_application"
pushbytes "increase_budget"
pushbytes "create_lock"
pushbytes "increase_lock_amount"
pushbytes "extend_lock_end_time"
pushbytes "create_checkpoints"
pushbytes "get_tiny_power_of"
pushbytes "get_tiny_power_of_at"
pushbytes "get_total_tiny_power"
pushbytes "get_total_tiny_power_at"
pushbytes "get_cumulative_power_of_at"
pushbytes "get_total_cumulative_power_at"
pushbytes "get_account_cumulative_power_delta"
pushbytes "get_total_cumulative_power_delta"
pushbytes "withdraw"
pushbytes "get_box"
pushbytes "delete_account_power_boxes"
pushbytes "delete_account_state"
pushbytes "init"
txna ApplicationArgs 0
match route_create_application route_increase_budget route_create_lock route_increase_lock_amount route_extend_lock_end_time route_create_checkpoints route_get_tiny_power_of route_get_tiny_power_of_at route_get_total_tiny_power route_get_total_tiny_power_at route_get_cumulative_power_of_at route_get_total_cumulative_power_at route_get_account_cumulative_power_delta route_get_total_cumulative_power_delta route_withdraw route_get_box route_delete_account_power_boxes route_delete_account_state route_init
err                                                         // unexpected value
route_create_application:
    txn ApplicationID; pushint 0; ==; assert                // ApplicationID == 0
    txna ApplicationArgs 1; btoi 
    callsub __func__create_application
    pushint 1; return
route_increase_budget:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    callsub __func__increase_budget
    pushint 1; return
route_create_lock:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    txna ApplicationArgs 1; btoi 
    callsub __func__create_lock
    pushint 1; return
route_increase_lock_amount:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    callsub __func__increase_lock_amount
    pushint 1; return
route_extend_lock_end_time:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    txna ApplicationArgs 1; btoi 
    callsub __func__extend_lock_end_time
    pushint 1; return
route_create_checkpoints:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    callsub __func__create_checkpoints
    pushint 1; return
route_get_tiny_power_of:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    txna ApplicationArgs 1
    callsub __func__get_tiny_power_of
    // return int
    // uncover 0 int
    itob
    pushbytes 0x151f7c75; swap; concat; log                 // arc4 return log
    pushint 1; return
route_get_tiny_power_of_at:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    txna ApplicationArgs 1
    txna ApplicationArgs 2; btoi 
    txna ApplicationArgs 3; btoi 
    callsub __func__get_tiny_power_of_at
    // return int
    // uncover 0 int
    itob
    pushbytes 0x151f7c75; swap; concat; log                 // arc4 return log
    pushint 1; return
route_get_total_tiny_power:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    callsub __func__get_total_tiny_power
    // return int
    // uncover 0 int
    itob
    pushbytes 0x151f7c75; swap; concat; log                 // arc4 return log
    pushint 1; return
route_get_total_tiny_power_at:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    txna ApplicationArgs 1; btoi 
    txna ApplicationArgs 2; btoi 
    callsub __func__get_total_tiny_power_at
    // return int
    // uncover 0 int
    itob
    pushbytes 0x151f7c75; swap; concat; log                 // arc4 return log
    pushint 1; return
route_get_cumulative_power_of_at:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    txna ApplicationArgs 1
    txna ApplicationArgs 2; btoi 
    txna ApplicationArgs 3; btoi 
    callsub __func__get_cumulative_power_of_at
    // return bytes
    // uncover 0 bytes
    pushbytes 0x151f7c75; swap; concat; log                 // arc4 return log
    pushint 1; return
route_get_total_cumulative_power_at:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    txna ApplicationArgs 1; btoi 
    txna ApplicationArgs 2; btoi 
    callsub __func__get_total_cumulative_power_at
    // return bytes
    // uncover 0 bytes
    pushbytes 0x151f7c75; swap; concat; log                 // arc4 return log
    pushint 1; return
route_get_account_cumulative_power_delta:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    txna ApplicationArgs 1
    txna ApplicationArgs 2; btoi 
    txna ApplicationArgs 3; btoi 
    txna ApplicationArgs 4; btoi 
    txna ApplicationArgs 5; btoi 
    callsub __func__get_account_cumulative_power_delta
    // return bytes
    // uncover 0 bytes
    pushbytes 0x151f7c75; swap; concat; log                 // arc4 return log
    pushint 1; return
route_get_total_cumulative_power_delta:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    txna ApplicationArgs 1; btoi 
    txna ApplicationArgs 2; btoi 
    txna ApplicationArgs 3; btoi 
    txna ApplicationArgs 4; btoi 
    callsub __func__get_total_cumulative_power_delta
    // return bytes
    // uncover 0 bytes
    pushbytes 0x151f7c75; swap; concat; log                 // arc4 return log
    pushint 1; return
route_withdraw:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    callsub __func__withdraw
    pushint 1; return
route_get_box:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    txna ApplicationArgs 1
    callsub __func__get_box
    // return int, bytes, bytes
    // uncover 0 int
    itob
    uncover 1                                               // bytes
    uncover 2                                               // bytes
    concat
    concat
    pushbytes 0x151f7c75; swap; concat; log                 // arc4 return log
    pushint 1; return
route_delete_account_power_boxes:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    txna ApplicationArgs 1; btoi 
    callsub __func__delete_account_power_boxes
    pushint 1; return
route_delete_account_state:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    callsub __func__delete_account_state
    pushint 1; return
route_init:
    txn OnCompletion; pushint 0; ==; assert                 // assert OnCompletion == NoOp
    callsub __func__init
    pushint 1; return


// tl:91: func create_application(tiny_asset_id: int):
__func__create_application:
    store 1                                                 // tiny_asset_id [int]
    // tl:92: app_global_put(TINY_ASSET_ID_KEY, tiny_asset_id)
    pushbytes TINY_ASSET_ID_KEY                             // "tiny_asset_id"
    load 1                                                  // tiny_asset_id
    app_global_put
    // tl:93: app_global_put(TOTAL_LOCKED_AMOUNT_KEY, 0)
    pushbytes TOTAL_LOCKED_AMOUNT_KEY                       // "total_locked_amount"
    pushint 0
    app_global_put
    // tl:94: app_global_put(TOTAL_POWER_COUNT_KEY, 0)
    pushbytes TOTAL_POWER_COUNT_KEY                         // "total_power_count"
    pushint 0
    app_global_put
    // tl:95: app_global_put(LAST_TOTAL_POWER_TIMESTAMP, 0)
    pushbytes LAST_TOTAL_POWER_TIMESTAMP                    // "last_total_power_timestamp"
    pushint 0
    app_global_put
    // tl:96: return
    retsub

// tl:100: func increase_budget():
__func__increase_budget:
    // Box read budget and opcode budget will be incread using this method.
    // tl:102: return
    retsub

// tl:106: func init():
__func__init:
    // create the first total power
    // tl:108: assert(!app_global_get(TOTAL_POWER_COUNT_KEY))
    pushbytes TOTAL_POWER_COUNT_KEY                         // "total_power_count"
    app_global_get
    !
    assert
    // tl:109: bytes total_power = construct_total_power(0, Global.LatestTimestamp, bzero(16), bzero(16)) [slot 2]
    pushint 0
    global LatestTimestamp
    pushint 16
    bzero
    pushint 16
    bzero
    callsub __func__construct_total_power
    store 2                                                 // total_power
    // tl:110: save_total_power(total_power)
    load 2                                                  // total_power
    callsub __func__save_total_power
    
    // opt-in to TINY
    // tl:113: transfer(app_global_get(TINY_ASSET_ID_KEY), 0, Global.CurrentApplicationAddress, Global.CurrentApplicationAddress)
    pushbytes TINY_ASSET_ID_KEY                             // "tiny_asset_id"
    app_global_get
    pushint 0
    global CurrentApplicationAddress
    global CurrentApplicationAddress
    callsub __func__transfer
    // tl:114: log(method("init()"))
    method "init()"
    log
    // tl:115: return
    retsub

// tl:119: func create_checkpoints():
__func__create_checkpoints:
    // tl:120: create_checkpoints_(0, bzero(16), 0)
    pushint 0
    pushint 16
    bzero
    pushint 0
    callsub __func__create_checkpoints_
    // tl:121: log(method("create_checkpoints()"))
    method "create_checkpoints()"
    log
    // tl:122: return
    retsub

// tl:126: func create_lock(lock_end_time: int):
__func__create_lock:
    store 3                                                 // lock_end_time [int]
    // This method is responsible for initiating a new lock for two categories of accounts:
    // 1) Accounts which have never had a token lock before.
    // 2) Accounts that have previously withdrawn their locked token amount.
    
    // tl:131: bytes user_address = Txn.Sender [slot 4]
    txn Sender
    store 4                                                 // user_address
    // tl:132: int amount = get_received_tiny_amount() [slot 5]
    callsub __func__get_received_tiny_amount
    store 5                                                 // amount
    
    // tl:134: assert(amount >= MIN_LOCK_AMOUNT)
    load 5                                                  // amount
    pushint MIN_LOCK_AMOUNT                                 // 10000000
    >=
    assert
    // tl:135: assert(!(lock_end_time % WEEK))
    load 3                                                  // lock_end_time
    pushint WEEK                                            // 604800
    %
    !
    assert
    // tl:136: assert(lock_end_time >= (Global.LatestTimestamp + (4 * WEEK)))
    load 3                                                  // lock_end_time
    global LatestTimestamp
    pushint 4
    pushint WEEK                                            // 604800
    *
    +
    >=
    assert
    // tl:137: assert(lock_end_time <= (Global.LatestTimestamp + MAX_LOCK_TIME))
    load 3                                                  // lock_end_time
    global LatestTimestamp
    pushint MAX_LOCK_TIME                                   // 126144000
    +
    <=
    assert
    
    // An account may have state box if it is not locking first time.
    // tl:140: _ = box_create(user_address, ACCOUNT_STATE_SIZE)
    load 4                                                  // user_address
    pushint ACCOUNT_STATE_SIZE                              // 32
    box_create
    pop                                                     // discarding value for _
    // tl:141: box<AccountState> account_state = Box(user_address) [slot 6]
    load 4                                                  // user_address
    store 6                                                 // box:account_state
    
    // Ensure that the account either has no previous lock or any existing locks have been fully withdrawn
    // tl:144: assert(!account_state.locked_amount)
    load 6; pushint 0; pushint 8; box_extract; btoi// account_state.locked_amount
    !
    assert
    
    // Update the account state
    // tl:147: account_state.locked_amount = amount
    load 5                                                  // amount
    itob; load 6; pushint 0; uncover 2; box_replace// boxset account_state.locked_amount
    // tl:148: account_state.lock_end_time = lock_end_time
    load 3                                                  // lock_end_time
    itob; load 6; pushint 8; uncover 2; box_replace// boxset account_state.lock_end_time
    
    // Increase the power count by one
    // tl:151: int account_power_index = account_state.power_count [slot 7]
    load 6; pushint 16; pushint 8; box_extract; btoi// account_state.power_count
    store 7                                                 // account_power_index
    // tl:152: account_state.power_count = account_power_index + 1
    load 7                                                  // account_power_index
    pushint 1
    +
    itob; load 6; pushint 16; uncover 2; box_replace// boxset account_state.power_count
    
    // tl:154: bytes slope = get_slope(amount) [slot 8]
    load 5                                                  // amount
    callsub __func__get_slope
    store 8                                                 // slope
    // tl:155: int bias = get_bias(slope, (lock_end_time - Global.LatestTimestamp)) [slot 9]
    load 8                                                  // slope
    load 3                                                  // lock_end_time
    global LatestTimestamp
    -
    callsub __func__get_bias
    store 9                                                 // bias
    
    // tl:157: bytes cumulative_power [slot 10]
    // tl:158: if account_power_index:
    load 7                                                  // account_power_index
    bz l0_else
    // then:
        // Account type 2
        // tl:160: AccountPower last_account_power = get_account_power(user_address, account_power_index - 1) [slot 11]
        load 4                                              // user_address
        load 7                                              // account_power_index
        pushint 1
        -
        callsub __func__get_account_power
        store 11                                            // last_account_power
        // tl:161: cumulative_power = last_account_power.cumulative_power
        load 11; extract 32 16// last_account_power.cumulative_power
        store 10                                            // cumulative_power
        b l0_end
    l0_else:
    // tl:162: else:
        // Account type 1
        // tl:164: cumulative_power = bzero(16)
        pushint 16
        bzero
        store 10                                            // cumulative_power
    l0_end:
    
    // Crate a new account power
    // tl:168: bytes account_power = construct_account_power(bias, Global.LatestTimestamp, slope, cumulative_power) [slot 12]
    load 9                                                  // bias
    global LatestTimestamp
    load 8                                                  // slope
    load 10                                                 // cumulative_power
    callsub __func__construct_account_power
    store 12                                                // account_power
    // tl:169: save_account_power(user_address, account_power_index, account_power)
    load 4                                                  // user_address
    load 7                                                  // account_power_index
    load 12                                                 // account_power
    callsub __func__save_account_power
    
    // tl:171: create_checkpoints_(bias, slope, 1)
    load 9                                                  // bias
    load 8                                                  // slope
    pushint 1
    callsub __func__create_checkpoints_
    // tl:172: update_or_create_slope_change(lock_end_time, slope)
    load 3                                                  // lock_end_time
    load 8                                                  // slope
    callsub __func__update_or_create_slope_change
    // tl:173: increase_total_locked_amount(amount)
    load 5                                                  // amount
    callsub __func__increase_total_locked_amount
    
    // create_lock(address, locked_amount, lock_end_time)
    // tl:176: log(Concat(method("create_lock(address,uint64,uint64)"), user_address, box_extract(user_address, 0, 16)))
    method "create_lock(address,uint64,uint64)"
    load 4                                                  // user_address
    load 4                                                  // user_address
    pushint 0
    pushint 16
    box_extract
    concat
    concat
    log
    // tl:177: return
    retsub

// tl:181: func increase_lock_amount():
__func__increase_lock_amount:
    // This method enables users to increase their currently locked token amount before the lock expiration time.
    
    // tl:184: bytes user_address = Txn.Sender [slot 13]
    txn Sender
    store 13                                                // user_address
    // tl:185: int amount = get_received_tiny_amount() [slot 14]
    callsub __func__get_received_tiny_amount
    store 14                                                // amount
    
    // tl:187: assert(amount >= MIN_LOCK_AMOUNT_INCREMENT)
    load 14                                                 // amount
    pushint MIN_LOCK_AMOUNT_INCREMENT                       // 10000000
    >=
    assert
    
    // tl:189: box<AccountState> account_state = OpenBox(user_address) [slot 15]
    load 13                                                 // user_address
    dup; box_len; assert; pushint 32; ==; assert            // len(box) == AccountState.size
    store 15                                                // box:account_state
    
    // Ensure that current lock is not expired.
    // tl:192: int lock_end_time = account_state.lock_end_time [slot 16]
    load 15; pushint 8; pushint 8; box_extract; btoi// account_state.lock_end_time
    store 16                                                // lock_end_time
    // tl:193: assert(lock_end_time > Global.LatestTimestamp)
    load 16                                                 // lock_end_time
    global LatestTimestamp
    >
    assert
    
    // Update locked_amount, power_count
    // tl:196: int old_locked_amount = account_state.locked_amount [slot 17]
    load 15; pushint 0; pushint 8; box_extract; btoi// account_state.locked_amount
    store 17                                                // old_locked_amount
    // tl:197: int new_locked_amount = old_locked_amount + amount [slot 18]
    load 17                                                 // old_locked_amount
    load 14                                                 // amount
    +
    store 18                                                // new_locked_amount
    // tl:198: account_state.locked_amount = new_locked_amount
    load 18                                                 // new_locked_amount
    itob; load 15; pushint 0; uncover 2; box_replace// boxset account_state.locked_amount
    
    // Increase the power count by one.
    // tl:201: int account_power_index = account_state.power_count [slot 19]
    load 15; pushint 16; pushint 8; box_extract; btoi// account_state.power_count
    store 19                                                // account_power_index
    // tl:202: account_state.power_count = account_power_index + 1
    load 19                                                 // account_power_index
    pushint 1
    +
    itob; load 15; pushint 16; uncover 2; box_replace// boxset account_state.power_count
    
    // tl:204: bytes old_locked_amount_slope = get_slope(old_locked_amount) [slot 20]
    load 17                                                 // old_locked_amount
    callsub __func__get_slope
    store 20                                                // old_locked_amount_slope
    // tl:205: bytes new_locked_amount_slope = get_slope(new_locked_amount) [slot 21]
    load 18                                                 // new_locked_amount
    callsub __func__get_slope
    store 21                                                // new_locked_amount_slope
    // tl:206: bytes slope_delta = new_locked_amount_slope b- old_locked_amount_slope [slot 22]
    load 21                                                 // new_locked_amount_slope
    load 20                                                 // old_locked_amount_slope
    b-
    store 22                                                // slope_delta
    
    // tl:208: int current_bias = get_bias(old_locked_amount_slope, (lock_end_time - Global.LatestTimestamp)) [slot 23]
    load 20                                                 // old_locked_amount_slope
    load 16                                                 // lock_end_time
    global LatestTimestamp
    -
    callsub __func__get_bias
    store 23                                                // current_bias
    // tl:209: int new_bias = get_bias(new_locked_amount_slope, (lock_end_time - Global.LatestTimestamp)) [slot 24]
    load 21                                                 // new_locked_amount_slope
    load 16                                                 // lock_end_time
    global LatestTimestamp
    -
    callsub __func__get_bias
    store 24                                                // new_bias
    // tl:210: int bias_delta = new_bias - current_bias [slot 25]
    load 24                                                 // new_bias
    load 23                                                 // current_bias
    -
    store 25                                                // bias_delta
    
    // tl:212: AccountPower last_account_power = get_account_power(user_address, account_power_index - 1) [slot 26]
    load 13                                                 // user_address
    load 19                                                 // account_power_index
    pushint 1
    -
    callsub __func__get_account_power
    store 26                                                // last_account_power
    // tl:213: int time_delta = Global.LatestTimestamp - last_account_power.timestamp [slot 27]
    global LatestTimestamp
    load 26; extract 8 8; btoi// last_account_power.timestamp
    -
    store 27                                                // time_delta
    
    // Using get_cumulative_power_1 is safe because the lock is not expired.
    // tl:216: bytes cumulative_power = last_account_power.cumulative_power b+ get_cumulative_power_1(last_account_power.bias, current_bias, time_delta) [slot 28]
    load 26; extract 32 16// last_account_power.cumulative_power
    load 26; extract 0 8; btoi// last_account_power.bias
    load 23                                                 // current_bias
    load 27                                                 // time_delta
    callsub __func__get_cumulative_power_1
    b+
    store 28                                                // cumulative_power
    
    // Crate a new account power
    // tl:219: bytes account_power = construct_account_power(new_bias, Global.LatestTimestamp, new_locked_amount_slope, cumulative_power) [slot 29]
    load 24                                                 // new_bias
    global LatestTimestamp
    load 21                                                 // new_locked_amount_slope
    load 28                                                 // cumulative_power
    callsub __func__construct_account_power
    store 29                                                // account_power
    // tl:220: save_account_power(user_address, account_power_index, account_power)
    load 13                                                 // user_address
    load 19                                                 // account_power_index
    load 29                                                 // account_power
    callsub __func__save_account_power
    
    // tl:222: create_checkpoints_(bias_delta, slope_delta, 1)
    load 25                                                 // bias_delta
    load 22                                                 // slope_delta
    pushint 1
    callsub __func__create_checkpoints_
    // tl:223: update_or_create_slope_change(lock_end_time, slope_delta)
    load 16                                                 // lock_end_time
    load 22                                                 // slope_delta
    callsub __func__update_or_create_slope_change
    // tl:224: increase_total_locked_amount(amount)
    load 14                                                 // amount
    callsub __func__increase_total_locked_amount
    
    // increase_lock_amount(address, locked_amount, lock_end_time, amount_delta)
    // tl:227: log(Concat(method("increase_lock_amount(address,uint64,uint64,uint64)"), user_address, box_extract(user_address, 0, 16), itob(amount)))
    method "increase_lock_amount(address,uint64,uint64,uint64)"
    load 13                                                 // user_address
    load 13                                                 // user_address
    pushint 0
    pushint 16
    box_extract
    load 14                                                 // amount
    itob
    concat
    concat
    concat
    log
    // tl:228: return
    retsub

// tl:232: func extend_lock_end_time(new_lock_end_time: int):
__func__extend_lock_end_time:
    store 30                                                // new_lock_end_time [int]
    // This method enables users to extend remaining lock duration.
    
    // tl:235: bytes user_address = Txn.Sender [slot 31]
    txn Sender
    store 31                                                // user_address
    
    // tl:237: box<AccountState> account_state = OpenBox(user_address) [slot 32]
    load 31                                                 // user_address
    dup; box_len; assert; pushint 32; ==; assert            // len(box) == AccountState.size
    store 32                                                // box:account_state
    // tl:238: int current_lock_end_time = account_state.lock_end_time [slot 33]
    load 32; pushint 8; pushint 8; box_extract; btoi// account_state.lock_end_time
    store 33                                                // current_lock_end_time
    // tl:239: assert(current_lock_end_time > Global.LatestTimestamp)
    load 33                                                 // current_lock_end_time
    global LatestTimestamp
    >
    assert
    
    // tl:241: assert(!(new_lock_end_time % WEEK))
    load 30                                                 // new_lock_end_time
    pushint WEEK                                            // 604800
    %
    !
    assert
    // tl:242: assert(new_lock_end_time <= (Global.LatestTimestamp + MAX_LOCK_TIME))
    load 30                                                 // new_lock_end_time
    global LatestTimestamp
    pushint MAX_LOCK_TIME                                   // 126144000
    +
    <=
    assert
    // tl:243: assert(new_lock_end_time >= (current_lock_end_time + (4 * WEEK)))
    load 30                                                 // new_lock_end_time
    load 33                                                 // current_lock_end_time
    pushint 4
    pushint WEEK                                            // 604800
    *
    +
    >=
    assert
    // ensured indirectly
    // assert(new_lock_end_time > Global.LatestTimestamp)
    
    // Increase the power count by one.
    // tl:248: int account_power_index = account_state.power_count [slot 34]
    load 32; pushint 16; pushint 8; box_extract; btoi// account_state.power_count
    store 34                                                // account_power_index
    // tl:249: account_state.power_count = account_power_index + 1
    load 34                                                 // account_power_index
    pushint 1
    +
    itob; load 32; pushint 16; uncover 2; box_replace// boxset account_state.power_count
    // tl:250: account_state.lock_end_time = new_lock_end_time
    load 30                                                 // new_lock_end_time
    itob; load 32; pushint 8; uncover 2; box_replace// boxset account_state.lock_end_time
    
    // tl:252: bytes slope = get_slope(account_state.locked_amount) [slot 35]
    load 32; pushint 0; pushint 8; box_extract; btoi// account_state.locked_amount
    callsub __func__get_slope
    store 35                                                // slope
    // tl:253: int current_bias = get_bias(slope, (current_lock_end_time - Global.LatestTimestamp)) [slot 36]
    load 35                                                 // slope
    load 33                                                 // current_lock_end_time
    global LatestTimestamp
    -
    callsub __func__get_bias
    store 36                                                // current_bias
    // tl:254: int new_bias = get_bias(slope, (new_lock_end_time - Global.LatestTimestamp)) [slot 37]
    load 35                                                 // slope
    load 30                                                 // new_lock_end_time
    global LatestTimestamp
    -
    callsub __func__get_bias
    store 37                                                // new_bias
    // tl:255: int bias_delta = new_bias - current_bias [slot 38]
    load 37                                                 // new_bias
    load 36                                                 // current_bias
    -
    store 38                                                // bias_delta
    
    // tl:257: AccountPower last_account_power = get_account_power(user_address, account_power_index - 1) [slot 39]
    load 31                                                 // user_address
    load 34                                                 // account_power_index
    pushint 1
    -
    callsub __func__get_account_power
    store 39                                                // last_account_power
    // tl:258: int time_delta = Global.LatestTimestamp - last_account_power.timestamp [slot 40]
    global LatestTimestamp
    load 39; extract 8 8; btoi// last_account_power.timestamp
    -
    store 40                                                // time_delta
    // tl:259: bytes cumulative_power = last_account_power.cumulative_power b+ get_cumulative_power_1(last_account_power.bias, current_bias, time_delta) [slot 41]
    load 39; extract 32 16// last_account_power.cumulative_power
    load 39; extract 0 8; btoi// last_account_power.bias
    load 36                                                 // current_bias
    load 40                                                 // time_delta
    callsub __func__get_cumulative_power_1
    b+
    store 41                                                // cumulative_power
    
    // Create AccountPower
    // tl:262: bytes account_power = construct_account_power(new_bias, Global.LatestTimestamp, slope, cumulative_power) [slot 42]
    load 37                                                 // new_bias
    global LatestTimestamp
    load 35                                                 // slope
    load 41                                                 // cumulative_power
    callsub __func__construct_account_power
    store 42                                                // account_power
    // tl:263: save_account_power(user_address, account_power_index, account_power)
    load 31                                                 // user_address
    load 34                                                 // account_power_index
    load 42                                                 // account_power
    callsub __func__save_account_power
    
    // tl:265: create_checkpoints_(bias_delta, bzero(16), 1)
    load 38                                                 // bias_delta
    pushint 16
    bzero
    pushint 1
    callsub __func__create_checkpoints_
    // tl:266: revert_slope_change(current_lock_end_time, slope)
    load 33                                                 // current_lock_end_time
    load 35                                                 // slope
    callsub __func__revert_slope_change
    // tl:267: update_or_create_slope_change(new_lock_end_time, slope)
    load 30                                                 // new_lock_end_time
    load 35                                                 // slope
    callsub __func__update_or_create_slope_change
    
    // extend_lock_end_time(address, locked_amount, lock_end_time, lock_end_time_delta)
    // tl:270: log(Concat(method("extend_lock_end_time(address,uint64,uint64,uint64)"), user_address, box_extract(user_address, 0, 16), itob(new_lock_end_time - current_lock_end_time)))
    method "extend_lock_end_time(address,uint64,uint64,uint64)"
    load 31                                                 // user_address
    load 31                                                 // user_address
    pushint 0
    pushint 16
    box_extract
    load 30                                                 // new_lock_end_time
    load 33                                                 // current_lock_end_time
    -
    itob
    concat
    concat
    concat
    log
    // tl:271: return
    retsub

// tl:275: func withdraw():
__func__withdraw:
    // tl:276: bytes user_address = Txn.Sender [slot 43]
    txn Sender
    store 43                                                // user_address
    
    // tl:278: box<AccountState> account_state = OpenBox(user_address) [slot 44]
    load 43                                                 // user_address
    dup; box_len; assert; pushint 32; ==; assert            // len(box) == AccountState.size
    store 44                                                // box:account_state
    // tl:279: int locked_amount = account_state.locked_amount [slot 45]
    load 44; pushint 0; pushint 8; box_extract; btoi// account_state.locked_amount
    store 45                                                // locked_amount
    
    // tl:281: assert(locked_amount)
    load 45                                                 // locked_amount
    assert
    // tl:282: assert(account_state.lock_end_time < Global.LatestTimestamp)
    load 44; pushint 8; pushint 8; box_extract; btoi// account_state.lock_end_time
    global LatestTimestamp
    <
    assert
    
    // tl:284: int account_power_index = account_state.power_count [slot 46]
    load 44; pushint 16; pushint 8; box_extract; btoi// account_state.power_count
    store 46                                                // account_power_index
    // tl:285: account_state.power_count = account_power_index + 1
    load 46                                                 // account_power_index
    pushint 1
    +
    itob; load 44; pushint 16; uncover 2; box_replace// boxset account_state.power_count
    
    // tl:287: AccountPower last_account_power = get_account_power(user_address, account_power_index - 1) [slot 47]
    load 43                                                 // user_address
    load 46                                                 // account_power_index
    pushint 1
    -
    callsub __func__get_account_power
    store 47                                                // last_account_power
    // tl:288: bytes cumulative_power = last_account_power.cumulative_power b+ get_cumulative_power_1(last_account_power.bias, 0, account_state.lock_end_time - last_account_power.timestamp) [slot 48]
    load 47; extract 32 16// last_account_power.cumulative_power
    load 47; extract 0 8; btoi// last_account_power.bias
    pushint 0
    load 44; pushint 8; pushint 8; box_extract; btoi// account_state.lock_end_time
    load 47; extract 8 8; btoi// last_account_power.timestamp
    -
    callsub __func__get_cumulative_power_1
    b+
    store 48                                                // cumulative_power
    
    // Create AccountPower
    // tl:291: bytes account_power = construct_account_power(0, account_state.lock_end_time, bzero(16), cumulative_power) [slot 49]
    pushint 0
    load 44; pushint 8; pushint 8; box_extract; btoi// account_state.lock_end_time
    pushint 16
    bzero
    load 48                                                 // cumulative_power
    callsub __func__construct_account_power
    store 49                                                // account_power
    // tl:292: save_account_power(user_address, account_power_index, account_power)
    load 43                                                 // user_address
    load 46                                                 // account_power_index
    load 49                                                 // account_power
    callsub __func__save_account_power
    
    // tl:294: transfer(app_global_get(TINY_ASSET_ID_KEY), locked_amount, Global.CurrentApplicationAddress, user_address)
    pushbytes TINY_ASSET_ID_KEY                             // "tiny_asset_id"
    app_global_get
    load 45                                                 // locked_amount
    global CurrentApplicationAddress
    load 43                                                 // user_address
    callsub __func__transfer
    // tl:295: decrease_total_locked_amount(locked_amount)
    load 45                                                 // locked_amount
    callsub __func__decrease_total_locked_amount
    
    // tl:297: account_state.locked_amount = 0
    pushint 0
    itob; load 44; pushint 0; uncover 2; box_replace// boxset account_state.locked_amount
    // tl:298: account_state.lock_end_time = 0
    pushint 0
    itob; load 44; pushint 8; uncover 2; box_replace// boxset account_state.lock_end_time
    
    // withdraw(user_address, amount)
    // tl:301: log(Concat(method("withdraw(address,uint64)"), user_address, itob(locked_amount)))
    method "withdraw(address,uint64)"
    load 43                                                 // user_address
    load 45                                                 // locked_amount
    itob
    concat
    concat
    log
    // tl:302: return
    retsub

// tl:306: func get_tiny_power_of(user_address: bytes) int:
__func__get_tiny_power_of:
    store 50                                                // user_address [bytes]
    // Current power can be calculated by using account state and account power.
    // The calculation is made using the account state to reduce required box references.
    // tl:309: int timestamp = Global.LatestTimestamp [slot 51]
    global LatestTimestamp
    store 51                                                // timestamp
    // tl:310: int tiny_power = 0 [slot 52]
    pushint 0
    store 52                                                // tiny_power
    
    // tl:312: int exists [slot 53]
    // tl:313: exists, _ = box_len(user_address)
    load 50                                                 // user_address
    box_len
    store 53                                                // exists
    pop                                                     // discarding value for _
    // tl:314: if exists:
    load 53                                                 // exists
    bz l1_end
    // then:
        // tl:315: box<AccountState> account_state = Box(user_address) [slot 54]
        load 50                                             // user_address
        store 54                                            // box:account_state
        // tl:316: if account_state.lock_end_time > timestamp:
        load 54; pushint 8; pushint 8; box_extract; btoi// account_state.lock_end_time
        load 51                                             // timestamp
        >
        bz l2_end
        // then:
            // tl:317: int remaining_time = account_state.lock_end_time - timestamp [slot 55]
            load 54; pushint 8; pushint 8; box_extract; btoi// account_state.lock_end_time
            load 51                                         // timestamp
            -
            store 55                                        // remaining_time
            // tl:318: bytes slope = get_slope(account_state.locked_amount) [slot 56]
            load 54; pushint 0; pushint 8; box_extract; btoi// account_state.locked_amount
            callsub __func__get_slope
            store 56                                        // slope
            // tl:319: tiny_power = get_bias(slope, remaining_time)
            load 56                                         // slope
            load 55                                         // remaining_time
            callsub __func__get_bias
            store 52                                        // tiny_power
        l2_end:
    l1_end:
    
    // tl:323: return tiny_power
    load 52                                                 // tiny_power
    retsub

// tl:327: func get_tiny_power_of_at(user_address: bytes, timestamp: int, index: int) int:
__func__get_tiny_power_of_at:
    store 57                                                // index [int]
    store 58                                                // timestamp [int]
    store 59                                                // user_address [bytes]
    // tl:328: int tiny_power = 0 [slot 60]
    pushint 0
    store 60                                                // tiny_power
    // tl:329: assert(timestamp <= Global.LatestTimestamp)
    load 58                                                 // timestamp
    global LatestTimestamp
    <=
    assert
    
    // tl:331: int exists [slot 61]
    // tl:332: exists, _ = box_len(user_address)
    load 59                                                 // user_address
    box_len
    store 61                                                // exists
    pop                                                     // discarding value for _
    // tl:333: if exists:
    load 61                                                 // exists
    bz l3_end
    // then:
        // tl:334: box<AccountState> account_state = Box(user_address) [slot 62]
        load 59                                             // user_address
        store 62                                            // box:account_state
        // tl:335: assert(index < account_state.power_count)
        load 57                                             // index
        load 62; pushint 16; pushint 8; box_extract; btoi// account_state.power_count
        <
        assert
        
        // account_power.timestamp <= timestamp < next_account_power.timestamp
        // tl:338: AccountPower account_power = get_account_power(user_address, index) [slot 63]
        load 59                                             // user_address
        load 57                                             // index
        callsub __func__get_account_power
        store 63                                            // account_power
        // tl:339: assert(account_power.timestamp <= timestamp)
        load 63; extract 8 8; btoi// account_power.timestamp
        load 58                                             // timestamp
        <=
        assert
        // tl:340: if (index + 1) < account_state.power_count:
        load 57                                             // index
        pushint 1
        +
        load 62; pushint 16; pushint 8; box_extract; btoi// account_state.power_count
        <
        bz l4_end
        // then:
            // tl:341: AccountPower next_account_power = get_account_power(user_address, index + 1) [slot 64]
            load 59                                         // user_address
            load 57                                         // index
            pushint 1
            +
            callsub __func__get_account_power
            store 64                                        // next_account_power
            // tl:342: assert(timestamp < next_account_power.timestamp)
            load 58                                         // timestamp
            load 64; extract 8 8; btoi// next_account_power.timestamp
            <
            assert
        l4_end:
        
        // tl:345: tiny_power = get_power(account_power.bias, account_power.slope, (timestamp - account_power.timestamp))
        load 63; extract 0 8; btoi// account_power.bias
        load 63; extract 16 16// account_power.slope
        load 58                                             // timestamp
        load 63; extract 8 8; btoi// account_power.timestamp
        -
        callsub __func__get_power
        store 60                                            // tiny_power
    l3_end:
    
    // tl:348: return tiny_power
    load 60                                                 // tiny_power
    retsub

// tl:352: func get_total_tiny_power() int:
__func__get_total_tiny_power:
    // tl:353: int timestamp = Global.LatestTimestamp [slot 65]
    global LatestTimestamp
    store 65                                                // timestamp
    // tl:354: int index = app_global_get(TOTAL_POWER_COUNT_KEY) - 1 [slot 66]
    pushbytes TOTAL_POWER_COUNT_KEY                         // "total_power_count"
    app_global_get
    pushint 1
    -
    store 66                                                // index
    
    // tl:356: TotalPower total_power = get_total_power(index) [slot 67]
    load 66                                                 // index
    callsub __func__get_total_power
    store 67                                                // total_power
    // Ensure that the latest checkpoint belongs to the same week so the slope is not changed.
    // tl:358: assert((total_power.timestamp / WEEK) == (timestamp / WEEK))
    load 67; extract 8 8; btoi// total_power.timestamp
    pushint WEEK                                            // 604800
    /
    load 65                                                 // timestamp
    pushint WEEK                                            // 604800
    /
    ==
    assert
    
    // tl:360: int tiny_power = get_power(total_power.bias, total_power.slope, (timestamp - total_power.timestamp)) [slot 68]
    load 67; extract 0 8; btoi// total_power.bias
    load 67; extract 16 16// total_power.slope
    load 65                                                 // timestamp
    load 67; extract 8 8; btoi// total_power.timestamp
    -
    callsub __func__get_power
    store 68                                                // tiny_power
    // tl:361: return tiny_power
    load 68                                                 // tiny_power
    retsub

// tl:365: func get_total_tiny_power_at(timestamp: int, total_power_index: int) int:
__func__get_total_tiny_power_at:
    store 69                                                // total_power_index [int]
    store 70                                                // timestamp [int]
    // tl:366: int tiny_power = 0 [slot 71]
    pushint 0
    store 71                                                // tiny_power
    // tl:367: assert(total_power_index < app_global_get(TOTAL_POWER_COUNT_KEY))
    load 69                                                 // total_power_index
    pushbytes TOTAL_POWER_COUNT_KEY                         // "total_power_count"
    app_global_get
    <
    assert
    // tl:368: assert(timestamp <= Global.LatestTimestamp)
    load 70                                                 // timestamp
    global LatestTimestamp
    <=
    assert
    
    // tl:370: TotalPower total_power = get_total_power(total_power_index) [slot 72]
    load 69                                                 // total_power_index
    callsub __func__get_total_power
    store 72                                                // total_power
    // Ensure that the latest checkpoint belongs to the same week so the slope is not changed.
    // tl:372: assert((total_power.timestamp / WEEK) == (timestamp / WEEK))
    load 72; extract 8 8; btoi// total_power.timestamp
    pushint WEEK                                            // 604800
    /
    load 70                                                 // timestamp
    pushint WEEK                                            // 604800
    /
    ==
    assert
    
    // tl:374: if total_power.timestamp <= timestamp:
    load 72; extract 8 8; btoi// total_power.timestamp
    load 70                                                 // timestamp
    <=
    bz l5_else
    // then:
        // tl:375: if (total_power_index + 1) < app_global_get(TOTAL_POWER_COUNT_KEY):
        load 69                                             // total_power_index
        pushint 1
        +
        pushbytes TOTAL_POWER_COUNT_KEY                     // "total_power_count"
        app_global_get
        <
        bz l6_end
        // then:
            // tl:376: TotalPower next_total_power = get_total_power(total_power_index + 1) [slot 73]
            load 69                                         // total_power_index
            pushint 1
            +
            callsub __func__get_total_power
            store 73                                        // next_total_power
            // tl:377: assert(timestamp < next_total_power.timestamp)
            load 70                                         // timestamp
            load 73; extract 8 8; btoi// next_total_power.timestamp
            <
            assert
        l6_end:
        
        // tl:380: tiny_power = get_power(total_power.bias, total_power.slope, (timestamp - total_power.timestamp))
        load 72; extract 0 8; btoi// total_power.bias
        load 72; extract 16 16// total_power.slope
        load 70                                             // timestamp
        load 72; extract 8 8; btoi// total_power.timestamp
        -
        callsub __func__get_power
        store 71                                            // tiny_power
        b l5_end
    l5_else:
    // tl:381: else:
        // Index must be 0, it indicates that the given timestamp predates the first checkpoint.
        // tl:383: assert(!total_power_index)
        load 69                                             // total_power_index
        !
        assert
    l5_end:
    
    // tl:386: return tiny_power
    load 71                                                 // tiny_power
    retsub

// tl:390: func get_account_cumulative_power_delta(user_address: bytes, timestamp_1: int, timestamp_2: int, account_power_index_1: int, account_power_index_2: int) bytes:
__func__get_account_cumulative_power_delta:
    store 74                                                // account_power_index_2 [int]
    store 75                                                // account_power_index_1 [int]
    store 76                                                // timestamp_2 [int]
    store 77                                                // timestamp_1 [int]
    store 78                                                // user_address [bytes]
    // tl:391: bytes account_cumulative_power_1 = get_cumulative_power_of_at(user_address, timestamp_1, account_power_index_1) [slot 79]
    load 78                                                 // user_address
    load 77                                                 // timestamp_1
    load 75                                                 // account_power_index_1
    callsub __func__get_cumulative_power_of_at
    store 79                                                // account_cumulative_power_1
    // tl:392: bytes account_cumulative_power_2 = get_cumulative_power_of_at(user_address, timestamp_2, account_power_index_2) [slot 80]
    load 78                                                 // user_address
    load 76                                                 // timestamp_2
    load 74                                                 // account_power_index_2
    callsub __func__get_cumulative_power_of_at
    store 80                                                // account_cumulative_power_2
    // tl:393: bytes cumulative_power_delta = account_cumulative_power_2 b- account_cumulative_power_1 [slot 81]
    load 80                                                 // account_cumulative_power_2
    load 79                                                 // account_cumulative_power_1
    b-
    store 81                                                // cumulative_power_delta
    
    // tl:395: return bzero(16) b| cumulative_power_delta
    pushint 16
    bzero
    load 81                                                 // cumulative_power_delta
    b|
    retsub

// tl:399: func get_total_cumulative_power_delta(timestamp_1: int, timestamp_2: int, total_power_index_1: int, total_power_index_2: int) bytes:
__func__get_total_cumulative_power_delta:
    store 82                                                // total_power_index_2 [int]
    store 83                                                // total_power_index_1 [int]
    store 84                                                // timestamp_2 [int]
    store 85                                                // timestamp_1 [int]
    // tl:400: bytes total_cumulative_power_1 = get_total_cumulative_power_at(timestamp_1, total_power_index_1) [slot 86]
    load 85                                                 // timestamp_1
    load 83                                                 // total_power_index_1
    callsub __func__get_total_cumulative_power_at
    store 86                                                // total_cumulative_power_1
    // tl:401: bytes total_cumulative_power_2 = get_total_cumulative_power_at(timestamp_2, total_power_index_2) [slot 87]
    load 84                                                 // timestamp_2
    load 82                                                 // total_power_index_2
    callsub __func__get_total_cumulative_power_at
    store 87                                                // total_cumulative_power_2
    // tl:402: bytes cumulative_power_delta = total_cumulative_power_2 b- total_cumulative_power_1 [slot 88]
    load 87                                                 // total_cumulative_power_2
    load 86                                                 // total_cumulative_power_1
    b-
    store 88                                                // cumulative_power_delta
    
    // tl:404: return bzero(16) b| cumulative_power_delta
    pushint 16
    bzero
    load 88                                                 // cumulative_power_delta
    b|
    retsub

// tl:408: func get_box(box_name: bytes) int, bytes, bytes:
__func__get_box:
    store 89                                                // box_name [bytes]
    // tl:409: int exists [slot 90]
    // tl:410: bytes data [slot 91]
    // tl:411: exists, data = box_get(box_name)
    load 89                                                 // box_name
    box_get
    store 90                                                // exists
    store 91                                                // data
    
    // tl:413: return exists, extract(6, 2, itob(len(data))), data
    load 91                                                 // data
    load 91                                                 // data
    len
    itob
    extract 6 2
    load 90                                                 // exists
    retsub

// tl:417: func delete_account_power_boxes(box_count: int):
__func__delete_account_power_boxes:
    store 92                                                // box_count [int]
    // tl:418: bytes user_address = Txn.Sender [slot 93]
    txn Sender
    store 93                                                // user_address
    
    // tl:420: box<AccountState> account_state = Box(user_address) [slot 94]
    load 93                                                 // user_address
    store 94                                                // box:account_state
    // tl:421: int account_power_count = account_state.power_count [slot 95]
    load 94; pushint 16; pushint 8; box_extract; btoi// account_state.power_count
    store 95                                                // account_power_count
    // tl:422: int deleted_account_power_count = account_state.deleted_power_count [slot 96]
    load 94; pushint 24; pushint 8; box_extract; btoi// account_state.deleted_power_count
    store 96                                                // deleted_account_power_count
    // tl:423: int account_power_count_to_delete = box_count * ACCOUNT_POWER_BOX_ARRAY_LEN [slot 97]
    load 92                                                 // box_count
    pushint ACCOUNT_POWER_BOX_ARRAY_LEN                     // 21
    *
    store 97                                                // account_power_count_to_delete
    
    // keep at least 1 account power to able to track cumulative power delta
    // tl:426: assert(account_power_count > (deleted_account_power_count + account_power_count_to_delete))
    load 95                                                 // account_power_count
    load 96                                                 // deleted_account_power_count
    load 97                                                 // account_power_count_to_delete
    +
    >
    assert
    // tl:427: account_state.deleted_power_count = deleted_account_power_count + account_power_count_to_delete
    load 96                                                 // deleted_account_power_count
    load 97                                                 // account_power_count_to_delete
    +
    itob; load 94; pushint 24; uncover 2; box_replace// boxset account_state.deleted_power_count
    
    // tl:429: int box_index_start = deleted_account_power_count / ACCOUNT_POWER_BOX_ARRAY_LEN [slot 98]
    load 96                                                 // deleted_account_power_count
    pushint ACCOUNT_POWER_BOX_ARRAY_LEN                     // 21
    /
    store 98                                                // box_index_start
    // tl:430: int box_index_end = box_index_start + box_count [slot 99]
    load 98                                                 // box_index_start
    load 92                                                 // box_count
    +
    store 99                                                // box_index_end
    
    // tl:432: int min_balance_delta = 0 [slot 100]
    pushint 0
    store 100                                               // min_balance_delta
    // tl:433: for i in box_index_start:box_index_end:
        load 98                                             // box_index_start
        store 101                                           // i
        l7_for:
        load 101                                            // i
        load 99                                             // box_index_end
        ==
        bnz l7_end
        // tl:434: min_balance_delta = min_balance_delta + delete_box(Concat(user_address, itob(i)))
        load 100                                            // min_balance_delta
        load 93                                             // user_address
        load 101                                            // i
        itob
        concat
        callsub __func__delete_box
        +
        store 100                                           // min_balance_delta
        load 101                                            // i
        pushint 1
        +
        store 101                                           // i
        b l7_for
        l7_end:
    // tl:436: transfer(0, min_balance_delta, Global.CurrentApplicationAddress, user_address)
    pushint 0
    load 100                                                // min_balance_delta
    global CurrentApplicationAddress
    load 93                                                 // user_address
    callsub __func__transfer
    
    // address, box_index_start, box_count
    // tl:439: log(Concat(method("delete_account_power_boxes(address,uint64,uint64)"), user_address, itob(box_index_start), itob(box_count)))
    method "delete_account_power_boxes(address,uint64,uint64)"
    load 93                                                 // user_address
    load 98                                                 // box_index_start
    itob
    load 92                                                 // box_count
    itob
    concat
    concat
    concat
    log
    // tl:440: return
    retsub

// tl:444: func delete_account_state():
__func__delete_account_state:
    // tl:445: bytes user_address = Txn.Sender [slot 102]
    txn Sender
    store 102                                               // user_address
    
    // tl:447: box<AccountState> account_state = Box(user_address) [slot 103]
    load 102                                                // user_address
    store 103                                               // box:account_state
    // tl:448: int account_power_count = account_state.power_count [slot 104]
    load 103; pushint 16; pushint 8; box_extract; btoi// account_state.power_count
    store 104                                               // account_power_count
    // check the lock
    // tl:450: assert(!account_state.locked_amount)
    load 103; pushint 0; pushint 8; box_extract; btoi// account_state.locked_amount
    !
    assert
    // tl:451: assert(!account_state.lock_end_time)
    load 103; pushint 8; pushint 8; box_extract; btoi// account_state.lock_end_time
    !
    assert
    
    // tl:453: int deleted_account_power_count = account_state.deleted_power_count [slot 105]
    load 103; pushint 24; pushint 8; box_extract; btoi// account_state.deleted_power_count
    store 105                                               // deleted_account_power_count
    // tl:454: int box_index = deleted_account_power_count / ACCOUNT_POWER_BOX_ARRAY_LEN [slot 106]
    load 105                                                // deleted_account_power_count
    pushint ACCOUNT_POWER_BOX_ARRAY_LEN                     // 21
    /
    store 106                                               // box_index
    // tl:455: int box_count = 0 [slot 107]
    pushint 0
    store 107                                               // box_count
    
    // tl:457: int min_balance_delta = 0 [slot 108]
    pushint 0
    store 108                                               // min_balance_delta
    // tl:458: while account_power_count > deleted_account_power_count:
    l8_while:
        load 104                                            // account_power_count
        load 105                                            // deleted_account_power_count
        >
        bz l8_end
        // delete account power
        // tl:460: min_balance_delta = min_balance_delta + delete_box(Concat(user_address, itob(box_index)))
        load 108                                            // min_balance_delta
        load 102                                            // user_address
        load 106                                            // box_index
        itob
        concat
        callsub __func__delete_box
        +
        store 108                                           // min_balance_delta
        
        // tl:462: box_count = box_count + 1
        load 107                                            // box_count
        pushint 1
        +
        store 107                                           // box_count
        // tl:463: box_index = box_index + 1
        load 106                                            // box_index
        pushint 1
        +
        store 106                                           // box_index
        // tl:464: deleted_account_power_count = deleted_account_power_count + ACCOUNT_POWER_BOX_ARRAY_LEN
        load 105                                            // deleted_account_power_count
        pushint ACCOUNT_POWER_BOX_ARRAY_LEN                 // 21
        +
        store 105                                           // deleted_account_power_count
        b l8_while
        l8_end:
    
    // delete account state
    // tl:468: min_balance_delta = min_balance_delta + delete_box(user_address)
    load 108                                                // min_balance_delta
    load 102                                                // user_address
    callsub __func__delete_box
    +
    store 108                                               // min_balance_delta
    // tl:469: transfer(0, min_balance_delta, Global.CurrentApplicationAddress, user_address)
    pushint 0
    load 108                                                // min_balance_delta
    global CurrentApplicationAddress
    load 102                                                // user_address
    callsub __func__transfer
    
    // address, box_index_start, box_count
    // tl:472: log(Concat(method("delete_account_state(address,uint64,uint64)"), user_address, itob((box_index + 1) - box_count), itob(box_count)))
    method "delete_account_state(address,uint64,uint64)"
    load 102                                                // user_address
    load 106                                                // box_index
    pushint 1
    +
    load 107                                                // box_count
    -
    itob
    load 107                                                // box_count
    itob
    concat
    concat
    concat
    log
    // tl:473: return
    retsub

// tl:476: func construct_account_power(bias: int, timestamp: int, slope: bytes, cumulative_power: bytes) bytes:
__func__construct_account_power:
    store 109                                               // cumulative_power [bytes]
    store 110                                               // slope [bytes]
    store 111                                               // timestamp [int]
    store 112                                               // bias [int]
    // tl:477: return Concat(itob(bias), itob(timestamp), (bzero(16) b| slope), (bzero(16) b| cumulative_power))
    load 112                                                // bias
    itob
    load 111                                                // timestamp
    itob
    pushint 16
    bzero
    load 110                                                // slope
    b|
    pushint 16
    bzero
    load 109                                                // cumulative_power
    b|
    concat
    concat
    concat
    retsub

// tl:480: func save_account_power(address: bytes, index: int, data: bytes):
__func__save_account_power:
    store 113                                               // data [bytes]
    store 114                                               // index [int]
    store 115                                               // address [bytes]
    // tl:481: assert(len(data) == ACCOUNT_POWER_SIZE)
    load 113                                                // data
    len
    pushint ACCOUNT_POWER_SIZE                              // 48
    ==
    assert
    // tl:482: int box_index = index / ACCOUNT_POWER_BOX_ARRAY_LEN [slot 116]
    load 114                                                // index
    pushint ACCOUNT_POWER_BOX_ARRAY_LEN                     // 21
    /
    store 116                                               // box_index
    // tl:483: int array_index = index % ACCOUNT_POWER_BOX_ARRAY_LEN [slot 117]
    load 114                                                // index
    pushint ACCOUNT_POWER_BOX_ARRAY_LEN                     // 21
    %
    store 117                                               // array_index
    // tl:484: bytes box_name = Concat(address, itob(box_index)) [slot 118]
    load 115                                                // address
    load 116                                                // box_index
    itob
    concat
    store 118                                               // box_name
    // tl:485: _ = box_create(box_name, ACCOUNT_POWER_BOX_SIZE)
    load 118                                                // box_name
    pushint ACCOUNT_POWER_BOX_SIZE                          // 1008
    box_create
    pop                                                     // discarding value for _
    // tl:486: box_replace(box_name, (array_index * ACCOUNT_POWER_SIZE), data)
    load 118                                                // box_name
    load 117                                                // array_index
    pushint ACCOUNT_POWER_SIZE                              // 48
    *
    load 113                                                // data
    box_replace
    
    // tl:488: log(Concat(method("account_power(address,uint64,uint64,uint64,uint128,uint128)"), address, itob(index), data))
    method "account_power(address,uint64,uint64,uint64,uint128,uint128)"
    load 115                                                // address
    load 114                                                // index
    itob
    load 113                                                // data
    concat
    concat
    concat
    log
    // tl:489: return
    retsub

// tl:492: func get_account_power(address: bytes, index: int) AccountPower:
__func__get_account_power:
    store 119                                               // index [int]
    store 120                                               // address [bytes]
    // tl:493: int box_index = index / ACCOUNT_POWER_BOX_ARRAY_LEN [slot 121]
    load 119                                                // index
    pushint ACCOUNT_POWER_BOX_ARRAY_LEN                     // 21
    /
    store 121                                               // box_index
    // tl:494: int array_index = index % ACCOUNT_POWER_BOX_ARRAY_LEN [slot 122]
    load 119                                                // index
    pushint ACCOUNT_POWER_BOX_ARRAY_LEN                     // 21
    %
    store 122                                               // array_index
    // tl:495: bytes box_name = Concat(address, itob(box_index)) [slot 123]
    load 120                                                // address
    load 121                                                // box_index
    itob
    concat
    store 123                                               // box_name
    // tl:496: return Cast(box_extract(box_name, (array_index * ACCOUNT_POWER_SIZE), ACCOUNT_POWER_SIZE), AccountPower)
    load 123                                                // box_name
    load 122                                                // array_index
    pushint ACCOUNT_POWER_SIZE                              // 48
    *
    pushint ACCOUNT_POWER_SIZE                              // 48
    box_extract
    dup; len; pushint 48; ==; assert// Bytes Size Assertion: 48 bytes
    retsub

// tl:499: func construct_total_power(bias: int, timestamp: int, slope: bytes, cumulative_power: bytes) bytes:
__func__construct_total_power:
    store 124                                               // cumulative_power [bytes]
    store 125                                               // slope [bytes]
    store 126                                               // timestamp [int]
    store 127                                               // bias [int]
    // tl:500: return Concat(itob(bias), itob(timestamp), (bzero(16) b| slope), (bzero(16) b| cumulative_power))
    load 127                                                // bias
    itob
    load 126                                                // timestamp
    itob
    pushint 16
    bzero
    load 125                                                // slope
    b|
    pushint 16
    bzero
    load 124                                                // cumulative_power
    b|
    concat
    concat
    concat
    retsub

// tl:503: func save_total_power(data: bytes):
__func__save_total_power:
    store 128                                               // data [bytes]
    // tl:504: int index = app_global_get(TOTAL_POWER_COUNT_KEY) [slot 129]
    pushbytes TOTAL_POWER_COUNT_KEY                         // "total_power_count"
    app_global_get
    store 129                                               // index
    
    // tl:506: assert(len(data) == TOTAL_POWER_SIZE)
    load 128                                                // data
    len
    pushint TOTAL_POWER_SIZE                                // 48
    ==
    assert
    // tl:507: int box_index = index / TOTAL_POWER_BOX_ARRAY_LEN [slot 130]
    load 129                                                // index
    pushint TOTAL_POWER_BOX_ARRAY_LEN                       // 21
    /
    store 130                                               // box_index
    // tl:508: int array_index = index % TOTAL_POWER_BOX_ARRAY_LEN [slot 131]
    load 129                                                // index
    pushint TOTAL_POWER_BOX_ARRAY_LEN                       // 21
    %
    store 131                                               // array_index
    // tl:509: bytes box_name = Concat(TOTAL_POWER_BOX_PREFIX, itob(box_index)) [slot 132]
    pushbytes TOTAL_POWER_BOX_PREFIX                        // "tp"
    load 130                                                // box_index
    itob
    concat
    store 132                                               // box_name
    // tl:510: _ = box_create(box_name, TOTAL_POWER_BOX_SIZE)
    load 132                                                // box_name
    pushint TOTAL_POWER_BOX_SIZE                            // 1008
    box_create
    pop                                                     // discarding value for _
    // tl:511: box_replace(box_name, (array_index * TOTAL_POWER_SIZE), data)
    load 132                                                // box_name
    load 131                                                // array_index
    pushint TOTAL_POWER_SIZE                                // 48
    *
    load 128                                                // data
    box_replace
    
    // tl:513: log(Concat(method("total_power(uint64,uint64,uint64,uint128,uint128)"), itob(index), data))
    method "total_power(uint64,uint64,uint64,uint128,uint128)"
    load 129                                                // index
    itob
    load 128                                                // data
    concat
    concat
    log
    // tl:514: app_global_put(TOTAL_POWER_COUNT_KEY, index + 1)
    pushbytes TOTAL_POWER_COUNT_KEY                         // "total_power_count"
    load 129                                                // index
    pushint 1
    +
    app_global_put
    // tl:515: app_global_put(LAST_TOTAL_POWER_TIMESTAMP, extract_uint64(data, 8))
    pushbytes LAST_TOTAL_POWER_TIMESTAMP                    // "last_total_power_timestamp"
    load 128                                                // data
    pushint 8
    extract_uint64
    app_global_put
    // tl:516: return
    retsub

// tl:519: func get_total_power(index: int) TotalPower:
__func__get_total_power:
    store 133                                               // index [int]
    // tl:520: int box_index = index / TOTAL_POWER_BOX_ARRAY_LEN [slot 134]
    load 133                                                // index
    pushint TOTAL_POWER_BOX_ARRAY_LEN                       // 21
    /
    store 134                                               // box_index
    // tl:521: int array_index = index % TOTAL_POWER_BOX_ARRAY_LEN [slot 135]
    load 133                                                // index
    pushint TOTAL_POWER_BOX_ARRAY_LEN                       // 21
    %
    store 135                                               // array_index
    // tl:522: bytes box_name = Concat(TOTAL_POWER_BOX_PREFIX, itob(box_index)) [slot 136]
    pushbytes TOTAL_POWER_BOX_PREFIX                        // "tp"
    load 134                                                // box_index
    itob
    concat
    store 136                                               // box_name
    // tl:523: return Cast(box_extract(box_name, (array_index * TOTAL_POWER_SIZE), TOTAL_POWER_SIZE), TotalPower)
    load 136                                                // box_name
    load 135                                                // array_index
    pushint TOTAL_POWER_SIZE                                // 48
    *
    pushint TOTAL_POWER_SIZE                                // 48
    box_extract
    dup; len; pushint 48; ==; assert// Bytes Size Assertion: 48 bytes
    retsub

// tl:527: func get_cumulative_power_of_at(user_address: bytes, timestamp: int, account_power_index: int) bytes:
__func__get_cumulative_power_of_at:
    store 137                                               // account_power_index [int]
    store 138                                               // timestamp [int]
    store 139                                               // user_address [bytes]
    // tl:528: bytes cumulative_power [slot 140]
    // tl:529: assert(timestamp <= Global.LatestTimestamp)
    load 138                                                // timestamp
    global LatestTimestamp
    <=
    assert
    
    // tl:531: bytes cumulative_power_delta [slot 141]
    // tl:532: int exists [slot 142]
    // tl:533: exists, _ = box_len(user_address)
    load 139                                                // user_address
    box_len
    store 142                                               // exists
    pop                                                     // discarding value for _
    // tl:534: if exists:
    load 142                                                // exists
    bz l9_end
    // then:
        // tl:535: box<AccountState> account_state = Box(user_address) [slot 143]
        load 139                                            // user_address
        store 143                                           // box:account_state
        // tl:536: assert(account_power_index < account_state.power_count)
        load 137                                            // account_power_index
        load 143; pushint 16; pushint 8; box_extract; btoi// account_state.power_count
        <
        assert
        
        // account_power.timestamp <= timestamp < next_account_power.timestamp
        // tl:539: AccountPower account_power = get_account_power(user_address, account_power_index) [slot 144]
        load 139                                            // user_address
        load 137                                            // account_power_index
        callsub __func__get_account_power
        store 144                                           // account_power
        // tl:540: if account_power.timestamp <= timestamp:
        load 144; extract 8 8; btoi// account_power.timestamp
        load 138                                            // timestamp
        <=
        bz l10_else
        // then:
            // assert(timestamp > account_power.timestamp)
            // tl:542: if (account_power_index + 1) < account_state.power_count:
            load 137                                        // account_power_index
            pushint 1
            +
            load 143; pushint 16; pushint 8; box_extract; btoi// account_state.power_count
            <
            bz l11_end
            // then:
                // tl:543: AccountPower next_account_power = get_account_power(user_address, account_power_index + 1) [slot 145]
                load 139                                    // user_address
                load 137                                    // account_power_index
                pushint 1
                +
                callsub __func__get_account_power
                store 145                                   // next_account_power
                // tl:544: assert(timestamp < next_account_power.timestamp)
                load 138                                    // timestamp
                load 145; extract 8 8; btoi// next_account_power.timestamp
                <
                assert
            l11_end:
            
            // tl:547: int time_delta = timestamp - account_power.timestamp [slot 146]
            load 138                                        // timestamp
            load 144; extract 8 8; btoi// account_power.timestamp
            -
            store 146                                       // time_delta
            // tl:548: int bias_delta = get_bias(account_power.slope, time_delta) [slot 147]
            load 144; extract 16 16// account_power.slope
            load 146                                        // time_delta
            callsub __func__get_bias
            store 147                                       // bias_delta
            // tl:549: if bias_delta < account_power.bias:
            load 147                                        // bias_delta
            load 144; extract 0 8; btoi// account_power.bias
            <
            bz l12_else
            // then:
                // tl:550: cumulative_power_delta = get_cumulative_power_1(account_power.bias, (account_power.bias - bias_delta), time_delta)
                load 144; extract 0 8; btoi// account_power.bias
                load 144; extract 0 8; btoi// account_power.bias
                load 147                                    // bias_delta
                -
                load 146                                    // time_delta
                callsub __func__get_cumulative_power_1
                store 141                                   // cumulative_power_delta
                b l12_end
            l12_else:
            // tl:551: else:
                // tl:552: cumulative_power_delta = get_cumulative_power_2(account_power.bias, account_power.slope)
                load 144; extract 0 8; btoi// account_power.bias
                load 144; extract 16 16// account_power.slope
                callsub __func__get_cumulative_power_2
                store 141                                   // cumulative_power_delta
            l12_end:
            
            // tl:555: cumulative_power = bzero(16) b| (account_power.cumulative_power b+ cumulative_power_delta)
            pushint 16
            bzero
            load 144; extract 32 16// account_power.cumulative_power
            load 141                                        // cumulative_power_delta
            b+
            b|
            store 140                                       // cumulative_power
            b l10_end
        l10_else:
        // tl:556: else:
            // Index must be 0, it indicates that the given timestamp predates the first checkpoint.
            // tl:558: assert(!account_power_index)
            load 137                                        // account_power_index
            !
            assert
            // tl:559: cumulative_power = bzero(16)
            pushint 16
            bzero
            store 140                                       // cumulative_power
        l10_end:
    l9_end:
    
    // tl:563: return cumulative_power
    load 140                                                // cumulative_power
    retsub

// tl:567: func get_total_cumulative_power_at(timestamp: int, total_power_index: int) bytes:
__func__get_total_cumulative_power_at:
    store 148                                               // total_power_index [int]
    store 149                                               // timestamp [int]
    // tl:568: bytes total_cumulative_power [slot 150]
    // tl:569: assert(total_power_index < app_global_get(TOTAL_POWER_COUNT_KEY))
    load 148                                                // total_power_index
    pushbytes TOTAL_POWER_COUNT_KEY                         // "total_power_count"
    app_global_get
    <
    assert
    // tl:570: assert(timestamp <= Global.LatestTimestamp)
    load 149                                                // timestamp
    global LatestTimestamp
    <=
    assert
    
    // tl:572: bytes cumulative_power_delta [slot 151]
    // tl:573: TotalPower total_power = get_total_power(total_power_index) [slot 152]
    load 148                                                // total_power_index
    callsub __func__get_total_power
    store 152                                               // total_power
    
    // tl:575: if total_power.timestamp <= timestamp:
    load 152; extract 8 8; btoi// total_power.timestamp
    load 149                                                // timestamp
    <=
    bz l13_else
    // then:
        // tl:576: if (total_power_index + 1) < app_global_get(TOTAL_POWER_COUNT_KEY):
        load 148                                            // total_power_index
        pushint 1
        +
        pushbytes TOTAL_POWER_COUNT_KEY                     // "total_power_count"
        app_global_get
        <
        bz l14_end
        // then:
            // tl:577: TotalPower next_total_power = get_total_power(total_power_index + 1) [slot 153]
            load 148                                        // total_power_index
            pushint 1
            +
            callsub __func__get_total_power
            store 153                                       // next_total_power
            // tl:578: assert(timestamp < next_total_power.timestamp)
            load 149                                        // timestamp
            load 153; extract 8 8; btoi// next_total_power.timestamp
            <
            assert
        l14_end:
        
        // Ensure that the latest checkpoint belongs to the same week so the slope is not changed.
        // tl:582: assert((total_power.timestamp / WEEK) == (timestamp / WEEK))
        load 152; extract 8 8; btoi// total_power.timestamp
        pushint WEEK                                        // 604800
        /
        load 149                                            // timestamp
        pushint WEEK                                        // 604800
        /
        ==
        assert
        
        // tl:584: int time_delta = timestamp - total_power.timestamp [slot 154]
        load 149                                            // timestamp
        load 152; extract 8 8; btoi// total_power.timestamp
        -
        store 154                                           // time_delta
        // tl:585: int bias_delta = get_bias(total_power.slope, time_delta) [slot 155]
        load 152; extract 16 16// total_power.slope
        load 154                                            // time_delta
        callsub __func__get_bias
        store 155                                           // bias_delta
        // tl:586: if bias_delta < total_power.bias:
        load 155                                            // bias_delta
        load 152; extract 0 8; btoi// total_power.bias
        <
        bz l15_else
        // then:
            // tl:587: cumulative_power_delta = get_cumulative_power_1(total_power.bias, (total_power.bias - bias_delta), time_delta)
            load 152; extract 0 8; btoi// total_power.bias
            load 152; extract 0 8; btoi// total_power.bias
            load 155                                        // bias_delta
            -
            load 154                                        // time_delta
            callsub __func__get_cumulative_power_1
            store 151                                       // cumulative_power_delta
            b l15_end
        l15_else:
        // tl:588: else:
            // tl:589: cumulative_power_delta = get_cumulative_power_2(total_power.bias, total_power.slope)
            load 152; extract 0 8; btoi// total_power.bias
            load 152; extract 16 16// total_power.slope
            callsub __func__get_cumulative_power_2
            store 151                                       // cumulative_power_delta
        l15_end:
        
        // tl:592: total_cumulative_power = bzero(16) b| (total_power.cumulative_power b+ cumulative_power_delta)
        pushint 16
        bzero
        load 152; extract 32 16// total_power.cumulative_power
        load 151                                            // cumulative_power_delta
        b+
        b|
        store 150                                           // total_cumulative_power
        b l13_end
    l13_else:
    // tl:593: else:
        // Index must be 0, it indicates that the given timestamp predates the first checkpoint.
        // tl:595: assert(!total_power_index)
        load 148                                            // total_power_index
        !
        assert
        // tl:596: total_cumulative_power = bzero(16)
        pushint 16
        bzero
        store 150                                           // total_cumulative_power
    l13_end:
    
    // tl:599: return total_cumulative_power
    load 150                                                // total_cumulative_power
    retsub

// tl:602: func create_checkpoints_(account_bias_delta: int, account_slope_delta: bytes, has_account_event: int):
__func__create_checkpoints_:
    store 156                                               // has_account_event [int]
    store 157                                               // account_slope_delta [bytes]
    store 158                                               // account_bias_delta [int]
    // https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy#L234
    
    // tl:605: TotalPower last_total_power = get_total_power(app_global_get(TOTAL_POWER_COUNT_KEY) - 1) [slot 159]
    pushbytes TOTAL_POWER_COUNT_KEY                         // "total_power_count"
    app_global_get
    pushint 1
    -
    callsub __func__get_total_power
    store 159                                               // last_total_power
    
    // tl:607: int bias = last_total_power.bias [slot 160]
    load 159; extract 0 8; btoi// last_total_power.bias
    store 160                                               // bias
    // tl:608: int last_checkpoint_timestamp = last_total_power.timestamp [slot 161]
    load 159; extract 8 8; btoi// last_total_power.timestamp
    store 161                                               // last_checkpoint_timestamp
    // tl:609: bytes slope = last_total_power.slope [slot 162]
    load 159; extract 16 16// last_total_power.slope
    store 162                                               // slope
    // tl:610: bytes cumulative_power = last_total_power.cumulative_power [slot 163]
    load 159; extract 32 16// last_total_power.cumulative_power
    store 163                                               // cumulative_power
    
    // tl:612: int temp_checkpoint_timestamp = (last_checkpoint_timestamp / WEEK) * WEEK [slot 164]
    load 161                                                // last_checkpoint_timestamp
    pushint WEEK                                            // 604800
    /
    pushint WEEK                                            // 604800
    *
    store 164                                               // temp_checkpoint_timestamp
    // tl:613: bytes slope_delta [slot 165]
    // tl:614: int bias_delta [slot 166]
    // tl:615: int time_delta [slot 167]
    
    // tl:617: int i = 0 [slot 168]
    pushint 0
    store 168                                               // i
    // tl:618: int stop = 9 [slot 169]
    pushint 9
    store 169                                               // stop
    // tl:619: while i < stop:
    l16_while:
        load 168                                            // i
        load 169                                            // stop
        <
        bz l16_end
        // tl:620: temp_checkpoint_timestamp = temp_checkpoint_timestamp + WEEK
        load 164                                            // temp_checkpoint_timestamp
        pushint WEEK                                        // 604800
        +
        store 164                                           // temp_checkpoint_timestamp
        // tl:621: slope_delta = itob(0)
        pushint 0
        itob
        store 165                                           // slope_delta
        
        // tl:623: if temp_checkpoint_timestamp > Global.LatestTimestamp:
        load 164                                            // temp_checkpoint_timestamp
        global LatestTimestamp
        >
        bz l17_end
        // then:
            // tl:624: temp_checkpoint_timestamp = Global.LatestTimestamp
            global LatestTimestamp
            store 164                                       // temp_checkpoint_timestamp
        l17_end:
        // tl:626: if !(temp_checkpoint_timestamp % WEEK):
        load 164                                            // temp_checkpoint_timestamp
        pushint WEEK                                        // 604800
        %
        !
        bz l18_end
        // then:
            // tl:627: _, slope_delta = box_get(Concat(SLOPE_CHANGE_BOX_PREFIX, itob(temp_checkpoint_timestamp)))
            pushbytes SLOPE_CHANGE_BOX_PREFIX               // "sc"
            load 164                                        // temp_checkpoint_timestamp
            itob
            concat
            box_get
            pop                                             // discarding value for _
            store 165                                       // slope_delta
        l18_end:
        
        // tl:630: time_delta = temp_checkpoint_timestamp - last_checkpoint_timestamp
        load 164                                            // temp_checkpoint_timestamp
        load 161                                            // last_checkpoint_timestamp
        -
        store 167                                           // time_delta
        // tl:631: bias_delta = get_bias(slope, time_delta)
        load 162                                            // slope
        load 167                                            // time_delta
        callsub __func__get_bias
        store 166                                           // bias_delta
        // tl:632: if bias_delta > bias:
        load 166                                            // bias_delta
        load 160                                            // bias
        >
        bz l19_else
        // then:
            // tl:633: cumulative_power = cumulative_power b+ get_cumulative_power_2(bias, slope)
            load 163                                        // cumulative_power
            load 160                                        // bias
            load 162                                        // slope
            callsub __func__get_cumulative_power_2
            b+
            store 163                                       // cumulative_power
            // tl:634: slope = bzero(16)
            pushint 16
            bzero
            store 162                                       // slope
            // tl:635: bias = 0
            pushint 0
            store 160                                       // bias
            b l19_end
        l19_else:
        // tl:636: else:
            // tl:637: cumulative_power = cumulative_power b+ get_cumulative_power_1(bias, (bias - bias_delta), time_delta)
            load 163                                        // cumulative_power
            load 160                                        // bias
            load 160                                        // bias
            load 166                                        // bias_delta
            -
            load 167                                        // time_delta
            callsub __func__get_cumulative_power_1
            b+
            store 163                                       // cumulative_power
            // tl:638: bias = bias - bias_delta
            load 160                                        // bias
            load 166                                        // bias_delta
            -
            store 160                                       // bias
        l19_end:
        
        // tl:641: if slope_delta b>= slope:
        load 165                                            // slope_delta
        load 162                                            // slope
        b>=
        bz l20_else
        // then:
            // tl:642: slope = bzero(16)
            pushint 16
            bzero
            store 162                                       // slope
            // tl:643: bias = 0
            pushint 0
            store 160                                       // bias
            b l20_end
        l20_else:
        // tl:644: else:
            // tl:645: slope = slope b- slope_delta
            load 162                                        // slope
            load 165                                        // slope_delta
            b-
            store 162                                       // slope
        l20_end:
        
        // tl:648: last_checkpoint_timestamp = temp_checkpoint_timestamp
        load 164                                            // temp_checkpoint_timestamp
        store 161                                           // last_checkpoint_timestamp
        // tl:649: if temp_checkpoint_timestamp == Global.LatestTimestamp:
        load 164                                            // temp_checkpoint_timestamp
        global LatestTimestamp
        ==
        bz l21_else
        // then:
            // tl:650: i = stop
            load 169                                        // stop
            store 168                                       // i
            // tl:651: if has_account_event:
            load 156                                        // has_account_event
            bz l22_else
            // then:
                // tl:652: save_total_power(construct_total_power(bias + account_bias_delta, last_checkpoint_timestamp, slope b+ account_slope_delta, cumulative_power))
                load 160                                    // bias
                load 158                                    // account_bias_delta
                +
                load 161                                    // last_checkpoint_timestamp
                load 162                                    // slope
                load 157                                    // account_slope_delta
                b+
                load 163                                    // cumulative_power
                callsub __func__construct_total_power
                callsub __func__save_total_power
                b l22_end
            l22_else:
            // tl:653: else:
                // tl:654: save_total_power(construct_total_power(bias, last_checkpoint_timestamp, slope, cumulative_power))
                load 160                                    // bias
                load 161                                    // last_checkpoint_timestamp
                load 162                                    // slope
                load 163                                    // cumulative_power
                callsub __func__construct_total_power
                callsub __func__save_total_power
            l22_end:
            b l21_end
        l21_else:
        // tl:656: else:
            // tl:657: i = i + 1
            load 168                                        // i
            pushint 1
            +
            store 168                                       // i
            // tl:658: save_total_power(construct_total_power(bias, last_checkpoint_timestamp, slope, cumulative_power))
            load 160                                        // bias
            load 161                                        // last_checkpoint_timestamp
            load 162                                        // slope
            load 163                                        // cumulative_power
            callsub __func__construct_total_power
            callsub __func__save_total_power
        l21_end:
        b l16_while
        l16_end:
    // tl:661: assert(!(has_account_event && (temp_checkpoint_timestamp != Global.LatestTimestamp)))
    load 156                                                // has_account_event
    load 164                                                // temp_checkpoint_timestamp
    global LatestTimestamp
    !=
    &&
    !
    assert
    // tl:662: return
    retsub

// tl:665: func get_cumulative_power_1(old_bias: int, new_bias: int, time_delta: int) bytes:
__func__get_cumulative_power_1:
    store 170                                               // time_delta [int]
    store 171                                               // new_bias [int]
    store 172                                               // old_bias [int]
    // (old_bias + new_bias) * time_delta / 2
    // tl:667: return ((itob(old_bias) b+ itob(new_bias)) b* itob(time_delta)) b/ itob(2)
    load 172                                                // old_bias
    itob
    load 171                                                // new_bias
    itob
    b+
    load 170                                                // time_delta
    itob
    b*
    pushint 2
    itob
    b/
    retsub

// tl:670: func get_cumulative_power_2(old_bias: int, slope: bytes) bytes:
__func__get_cumulative_power_2:
    store 173                                               // slope [bytes]
    store 174                                               // old_bias [int]
    // time_delta = old_bias / slope
    // (old_bias + new_bias) * (old_bias / slope) / 2, new_bias = 0
    // (old_bias * old_bias) / (slope * 2)
    // tl:674: if slope != bzero(16):
    load 173                                                // slope
    pushint 16
    bzero
    !=
    bz l23_end
    // then:
        // tl:675: return ((itob(old_bias) b* itob(old_bias)) b* TWO_TO_THE_64) b/ (slope b* itob(2))
        load 174                                            // old_bias
        itob
        load 174                                            // old_bias
        itob
        b*
        pushbytes TWO_TO_THE_64                             // "\x01\x00\x00\x00\x00\x00\x00\x00\x00"
        b*
        load 173                                            // slope
        pushint 2
        itob
        b*
        b/
        retsub
    l23_end:
    // tl:677: return bzero(16)
    pushint 16
    bzero
    retsub

// tl:680: func get_bias(slope: bytes, time: int) int:
__func__get_bias:
    store 175                                               // time [int]
    store 176                                               // slope [bytes]
    // tl:681: return btoi((slope b* itob(time)) b/ TWO_TO_THE_64)
    load 176                                                // slope
    load 175                                                // time
    itob
    b*
    pushbytes TWO_TO_THE_64                                 // "\x01\x00\x00\x00\x00\x00\x00\x00\x00"
    b/
    btoi
    retsub

// tl:684: func get_slope(locked_amount: int) bytes:
__func__get_slope:
    store 177                                               // locked_amount [int]
    // tl:685: return (itob(locked_amount) b* TWO_TO_THE_64) b/ itob(MAX_LOCK_TIME)
    load 177                                                // locked_amount
    itob
    pushbytes TWO_TO_THE_64                                 // "\x01\x00\x00\x00\x00\x00\x00\x00\x00"
    b*
    pushint MAX_LOCK_TIME                                   // 126144000
    itob
    b/
    retsub

// tl:688: func revert_slope_change(timestamp: int, slope: bytes):
__func__revert_slope_change:
    store 178                                               // slope [bytes]
    store 179                                               // timestamp [int]
    // tl:689: bytes box_name = Concat(SLOPE_CHANGE_BOX_PREFIX, itob(timestamp)) [slot 180]
    pushbytes SLOPE_CHANGE_BOX_PREFIX                       // "sc"
    load 179                                                // timestamp
    itob
    concat
    store 180                                               // box_name
    // tl:690: bytes new_slope = bzero(16) b| (box_extract(box_name, 0, 16) b- slope) [slot 181]
    pushint 16
    bzero
    load 180                                                // box_name
    pushint 0
    pushint 16
    box_extract
    load 178                                                // slope
    b-
    b|
    store 181                                               // new_slope
    // tl:691: box_put(box_name, new_slope)
    load 180                                                // box_name
    load 181                                                // new_slope
    box_put
    
    // tl:693: log(Concat(method("slope_change(uint64,uint128)"), itob(timestamp), new_slope))
    method "slope_change(uint64,uint128)"
    load 179                                                // timestamp
    itob
    load 181                                                // new_slope
    concat
    concat
    log
    // tl:694: return
    retsub

// tl:697: func update_or_create_slope_change(timestamp: int, slope: bytes):
__func__update_or_create_slope_change:
    store 182                                               // slope [bytes]
    store 183                                               // timestamp [int]
    // tl:698: bytes box_name = Concat(SLOPE_CHANGE_BOX_PREFIX, itob(timestamp)) [slot 184]
    pushbytes SLOPE_CHANGE_BOX_PREFIX                       // "sc"
    load 183                                                // timestamp
    itob
    concat
    store 184                                               // box_name
    // tl:699: bytes slope_delta [slot 185]
    // tl:700: _, slope_delta = box_get(box_name)
    load 184                                                // box_name
    box_get
    pop                                                     // discarding value for _
    store 185                                               // slope_delta
    // tl:701: bytes new_slope = bzero(16) b| (slope_delta b+ slope) [slot 186]
    pushint 16
    bzero
    load 185                                                // slope_delta
    load 182                                                // slope
    b+
    b|
    store 186                                               // new_slope
    // tl:702: box_put(box_name, new_slope)
    load 184                                                // box_name
    load 186                                                // new_slope
    box_put
    
    // tl:704: log(Concat(method("slope_change(uint64,uint128)"), itob(timestamp), new_slope))
    method "slope_change(uint64,uint128)"
    load 183                                                // timestamp
    itob
    load 186                                                // new_slope
    concat
    concat
    log
    // tl:705: return
    retsub

// tl:708: func get_power(bias: int, slope: bytes, time_delta: int) int:
__func__get_power:
    store 187                                               // time_delta [int]
    store 188                                               // slope [bytes]
    store 189                                               // bias [int]
    // tl:709: int bias_delta = get_bias(slope, time_delta) [slot 190]
    load 188                                                // slope
    load 187                                                // time_delta
    callsub __func__get_bias
    store 190                                               // bias_delta
    // tl:710: if bias_delta < bias:
    load 190                                                // bias_delta
    load 189                                                // bias
    <
    bz l24_end
    // then:
        // tl:711: return bias - bias_delta
        load 189                                            // bias
        load 190                                            // bias_delta
        -
        retsub
    l24_end:
    // tl:713: return 0
    pushint 0
    retsub

// tl:716: func increase_total_locked_amount(amount: int):
__func__increase_total_locked_amount:
    store 191                                               // amount [int]
    // tl:717: app_global_put(TOTAL_LOCKED_AMOUNT_KEY, app_global_get(TOTAL_LOCKED_AMOUNT_KEY) + amount)
    pushbytes TOTAL_LOCKED_AMOUNT_KEY                       // "total_locked_amount"
    pushbytes TOTAL_LOCKED_AMOUNT_KEY                       // "total_locked_amount"
    app_global_get
    load 191                                                // amount
    +
    app_global_put
    // tl:718: return
    retsub

// tl:721: func decrease_total_locked_amount(amount: int):
__func__decrease_total_locked_amount:
    store 192                                               // amount [int]
    // tl:722: app_global_put(TOTAL_LOCKED_AMOUNT_KEY, app_global_get(TOTAL_LOCKED_AMOUNT_KEY) - amount)
    pushbytes TOTAL_LOCKED_AMOUNT_KEY                       // "total_locked_amount"
    pushbytes TOTAL_LOCKED_AMOUNT_KEY                       // "total_locked_amount"
    app_global_get
    load 192                                                // amount
    -
    app_global_put
    // tl:723: return
    retsub

// tl:726: func get_received_tiny_amount() int:
__func__get_received_tiny_amount:
    // this function is designed to retrieve the amount of 'TINY' tokens that have been transferred from a user's account to the contract's account.
    // the asset transfer transaction must be positioned at the -1 index in the transaction group.
    
    // tl:730: assert(Txn.GroupIndex)
    txn GroupIndex
    assert
    // tl:731: int input_txn_index = Txn.GroupIndex - 1 [slot 193]
    txn GroupIndex
    pushint 1
    -
    store 193                                               // input_txn_index
    // tl:732: assert(Gtxn[input_txn_index].Sender == Txn.Sender)
    load 193                                                // input_txn_index
    gtxns Sender
    txn Sender
    ==
    assert
    // tl:733: assert(Gtxn[input_txn_index].TypeEnum == Axfer)
    load 193                                                // input_txn_index
    gtxns TypeEnum
    pushint 4                                               // Axfer
    ==
    assert
    // tl:734: assert(Gtxn[input_txn_index].AssetReceiver == Global.CurrentApplicationAddress)
    load 193                                                // input_txn_index
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    assert
    // tl:735: assert(Gtxn[input_txn_index].XferAsset == app_global_get(TINY_ASSET_ID_KEY))
    load 193                                                // input_txn_index
    gtxns XferAsset
    pushbytes TINY_ASSET_ID_KEY                             // "tiny_asset_id"
    app_global_get
    ==
    assert
    // tl:736: return Gtxn[input_txn_index].AssetAmount
    load 193                                                // input_txn_index
    gtxns AssetAmount
    retsub

// tl:739: func delete_box(box_name: bytes) int:
__func__delete_box:
    store 194                                               // box_name [bytes]
    // tl:740: int initial_min_balance = min_balance(Global.CurrentApplicationAddress) [slot 195]
    global CurrentApplicationAddress
    min_balance
    store 195                                               // initial_min_balance
    // tl:741: assert(box_del(box_name))
    load 194                                                // box_name
    box_del
    assert
    // tl:742: int final_min_balance = min_balance(Global.CurrentApplicationAddress) [slot 196]
    global CurrentApplicationAddress
    min_balance
    store 196                                               // final_min_balance
    // tl:743: int min_balance_delta = initial_min_balance - final_min_balance [slot 197]
    load 195                                                // initial_min_balance
    load 196                                                // final_min_balance
    -
    store 197                                               // min_balance_delta
    
    // tl:745: log(Concat(method("box_del(byte[])"), extract(6, 2, itob(len(box_name))), box_name))
    method "box_del(byte[])"
    load 194                                                // box_name
    len
    itob
    extract 6 2
    load 194                                                // box_name
    concat
    concat
    log
    // tl:746: return min_balance_delta
    load 197                                                // min_balance_delta
    retsub

// tl:749: func transfer(asset_id: int, amount: int, sender: bytes, receiver: bytes):
__func__transfer:
    store 198                                               // receiver [bytes]
    store 199                                               // sender [bytes]
    store 200                                               // amount [int]
    store 201                                               // asset_id [int]
    // This function is copied from Tinyman AMM Contracts V2.
    // "asset_id == 0" is updated as "!asset_id" for budget optimization.
    // https://github.com/tinymanorg/tinyman-amm-contracts-v2/blob/main/contracts/amm_approval.tl#L1146
    
    // tl:754: if !asset_id:
    load 201                                                // asset_id
    !
    bz l25_else
    // then:
        // tl:755: inner_txn:
        callsub _itxn_begin
            // tl:756: TypeEnum: Pay
            pushint 1                                       // Pay
            itxn_field TypeEnum
            // tl:757: Sender: sender
            load 199                                        // sender
            itxn_field Sender
            // tl:758: Receiver: receiver
            load 198                                        // receiver
            itxn_field Receiver
            // tl:759: Amount: amount
            load 200                                        // amount
            itxn_field Amount
            // tl:760: Fee: 0
            pushint 0
            itxn_field Fee
        callsub _itxn_submit
        // end inner_txn
        b l25_end
    l25_else:
    // tl:762: else:
        // tl:763: inner_txn:
        callsub _itxn_begin
            // tl:764: TypeEnum: Axfer
            pushint 4                                       // Axfer
            itxn_field TypeEnum
            // tl:765: Sender: sender
            load 199                                        // sender
            itxn_field Sender
            // tl:766: AssetReceiver: receiver
            load 198                                        // receiver
            itxn_field AssetReceiver
            // tl:767: AssetAmount: amount
            load 200                                        // amount
            itxn_field AssetAmount
            // tl:768: XferAsset: asset_id
            load 201                                        // asset_id
            itxn_field XferAsset
            // tl:769: Fee: 0
            pushint 0
            itxn_field Fee
        callsub _itxn_submit
        // end inner_txn
    l25_end:
    // tl:772: return
    retsub


_itxn_group_begin:
  load 202; !; assert                                       // ensure no group active
  int 1; store 202; retsub                                  // set group flag

_itxn_begin:
  load 202
  switch _itxn_begin__0 _itxn_begin__1 _itxn_begin__2
  err
  _itxn_begin__0: itxn_begin; retsub                        // no group
  _itxn_begin__1: itxn_begin; int 2; store 202; retsub      // start first txn of group
  _itxn_begin__2: itxn_next; retsub                         // start next txn of group

_itxn_submit:
  load 202
  bz _itxn_submit__0
  retsub                                                    // in a group, don't submit
  _itxn_submit__0: itxn_submit; retsub                      // no group, submit

_itxn_group_submit:
  itxn_submit
  int 0; store 202; retsub                                  // set group flag to 0

